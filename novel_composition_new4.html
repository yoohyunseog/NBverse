<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì†Œì„¤ êµ¬ì„± ìš”ì†Œ ê´€ë¦¬</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="js/searchAlgorithm.js"></script>
    <style>
        :root {
            --bg: #0e1116;
            --bg-alt: #131825;
            --card-bg: rgba(21, 26, 38, 0.85);
            --border: rgba(255, 255, 255, 0.08);
            --text: #e8edf7;
            --muted: #a9b3c7;
            --primary: #7c5cff;
            --primary-600: #6a48ff;
            --success: #2bd576;
            --danger: #ff5d5d;
            --warning: #ffc857;
            --info: #4fc3f7;
            --shadow: 0 8px 24px rgba(0,0,0,0.35);
            --shadow-soft: 0 6px 16px rgba(0,0,0,0.25);
            --radius: 14px;
            --surface: #131825; /* brighter than body bg */
        }
        body {
            background: var(--bg) !important;
            color: var(--text);
            padding: 0;
            margin: 0;
            width: 100%;
        }
        .main-container {
            width: 100%;
            margin: 0;
            padding: 0;
        }
        .card {
            background: var(--surface) !important;
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            backdrop-filter: saturate(140%) blur(10px);
            color: var(--text);
            margin-bottom: 0;
        }
        .card .card-header { border-bottom: 1px solid var(--border); background: var(--surface) !important; }
        .attribute-item {
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 16px;
            margin-bottom: 14px;
            background: var(--surface) !important;
            box-shadow: var(--shadow-soft);
            transition: transform 0.18s ease, box-shadow 0.18s ease, border-color 0.18s ease;
        }
        .attribute-item:hover { transform: translateY(-2px); box-shadow: 0 10px 26px rgba(0,0,0,0.35); border-color: rgba(124, 92, 255, 0.45); background: var(--surface) !important; }
        .attribute-header {
            text-align: left;
            margin-bottom: 10px;
        }
        .attribute-name {
            font-size: 1.06em;
            font-weight: 700;
            color: var(--text);
            letter-spacing: 0.2px;
        }
        .bit-display {
            font-size: 0.84em;
            color: var(--muted);
            margin-top: 6px;
        }
        .data-item {
            background: var(--surface) !important;
            padding: 12px;
            margin: 8px 0;
            border-left: 4px solid var(--success);
            border-radius: 8px;
        }
        .btn-sm {
            padding: 0.3rem 0.6rem;
            font-size: 0.875rem;
            border-radius: 9px;
        }
        .status {
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 0.84em;
        }
        .status-success {
            background: rgba(43, 213, 118, 0.15);
            color: var(--success);
        }
        .status-error {
            background: rgba(255, 93, 93, 0.15);
            color: var(--danger);
        }
        .status-info {
            background: rgba(79, 195, 247, 0.15);
            color: var(--info);
        }
        .attribute-card {
            cursor: pointer;
            transition: transform 0.18s ease, box-shadow 0.18s ease, border-color 0.18s ease;
            user-select: none;
            border: 1px solid var(--border);
            border-radius: 12px;
        }
        .attribute-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 28px rgba(0,0,0,0.35);
            border-color: rgba(124, 92, 255, 0.5) !important;
        }
        .attribute-card:active {
            transform: translateY(0);
        }
        .attribute-item.highlighted {
            background: linear-gradient(180deg, rgba(255, 200, 87, 0.1), rgba(255,255,255,0));
            border: 2px solid var(--warning);
            box-shadow: 0 0 0 4px rgba(255, 200, 87, 0.15), 0 10px 26px rgba(0,0,0,0.35);
            animation: highlight-pulse 1.6s ease-in-out;
        }
        @keyframes highlight-pulse {
            0%, 100% {
                box-shadow: 0 0 0 4px rgba(255, 200, 87, 0.12), 0 10px 26px rgba(0,0,0,0.35);
            }
            50% {
                box-shadow: 0 0 0 7px rgba(255, 200, 87, 0.22), 0 16px 40px rgba(0,0,0,0.45);
            }
        }
        .log-container {
            width: 100%;
            background: var(--surface) !important;
            color: #b9f6ca;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 10px;
            max-height: 300px;
            overflow-y: auto;
            border-top: 1px solid var(--border);
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);
        }
        .log-entry {
            margin-bottom: 4px;
            padding: 6px 8px;
            border-bottom: 1px dashed rgba(255,255,255,0.06);
            cursor: pointer;
            border-radius: 6px;
        }
        .log-entry:first-child {
            border-top: 1px dashed rgba(255,255,255,0.06);
        }
        .log-time {
            color: #7e8696;
            margin-right: 8px;
        }
        .log-message { color: #b9f6ca; }
        .log-error { color: #ff8a80; }
        .log-warn { color: #ffe57f; }
        .log-info { color: #80d8ff; }
        .log-entry:hover {
            background-color: rgba(255,255,255,0.03);
        }
        .chapter-item {
            background-color: var(--surface) !important;
            transition: transform 0.18s ease, background-color 0.18s ease, box-shadow 0.18s ease;
            border: 1px solid var(--border);
            border-radius: 10px;
            cursor: pointer;
        }
        .chapter-item:hover { background-color: var(--surface) !important; box-shadow: var(--shadow-soft); transform: translateY(-2px); }
        /* Scrollbar styling */
        .card-body::-webkit-scrollbar,
        #chaptersList::-webkit-scrollbar,
        .log-container::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        .card-body::-webkit-scrollbar-track,
        #chaptersList::-webkit-scrollbar-track,
        .log-container::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.04);
            border-radius: 10px;
        }
        .card-body::-webkit-scrollbar-thumb,
        #chaptersList::-webkit-scrollbar-thumb,
        .log-container::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, rgba(124,92,255,0.7), rgba(106,72,255,0.7));
            border-radius: 10px;
            border: 2px solid rgba(0,0,0,0.25);
        }
        .card-body::-webkit-scrollbar-thumb:hover,
        #chaptersList::-webkit-scrollbar-thumb:hover,
        .log-container::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, rgba(124,92,255,0.9), rgba(106,72,255,0.9));
        }
        /* Utility text colors aligning with theme */
        .text-muted { color: var(--muted) !important; }
        .text-primary { color: var(--primary) !important; }
        .btn-outline-primary { border-color: var(--primary); color: var(--primary); }
        .btn-outline-primary:hover { background: var(--primary); color: #fff; }
        .btn-primary { background: var(--primary); border-color: var(--primary-600); }
        .btn-primary:hover { background: var(--primary-600); border-color: var(--primary-600); }
        .btn-success { background: var(--success); border-color: #1fb865; }
        .btn-success:hover { filter: brightness(0.95); }
        .btn-outline-danger { color: var(--danger); border-color: var(--danger); }
        .btn-outline-danger:hover { background: var(--danger); color: #fff; }
        /* Unify all bootstrap bg variants to app background */
        .bg-primary, .bg-success, .bg-info, .bg-warning, .bg-danger, .bg-gradient,
        .bg-light, .bg-white, .card-header.bg-primary, .card-header.bg-success,
        .card-header.bg-info, .card-header.bg-warning, .card-header.bg-danger {
            background-color: var(--surface) !important;
            background-image: none !important;
        }
        .bg-light, .bg-white { border: 1px solid var(--border) !important; }
        .bg-light *, .bg-white * { color: var(--text) !important; }
        /* Form controls unify */
        .form-control, .form-select, textarea {
            background-color: var(--surface) !important;
            color: var(--text) !important;
            border: 1px solid var(--border) !important;
        }
        .form-control::placeholder, textarea::placeholder { color: var(--muted) !important; }
        /* GPT ì‘ë‹µ ì˜ì—­ ê°€ë…ì„± ë° ìë™ ë†’ì´ */
        #gptResponse {
            background-color: rgba(255,255,255,0.05) !important;
            color: var(--text) !important;
            border: 1px solid var(--border);
            max-height: none !important;
            height: auto !important;
            overflow-y: visible !important;
        }
        /* Light background readability */
        .bg-white, .bg-light, .attribute-item.bg-white, .attribute-item.bg-light {
            color: #111 !important;
        }
        .bg-white .text-muted, .bg-light .text-muted { color: #515a6b !important; }
        .bg-white small, .bg-light small { color: #374151 !important; }
        /* Modal theming */
        .modal-content, .modal-header, .modal-footer, .modal-body {
            background: var(--surface) !important;
            color: var(--text) !important;
            border-color: var(--border) !important;
        }
        .btn-close { filter: invert(1); opacity: 0.85; }
        .btn-close:hover { opacity: 1; }
        /* Floating reset button */
        .floating-reset {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1050;
            box-shadow: 0 10px 26px rgba(0,0,0,0.35);
            border-radius: 999px;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <h1 class="mb-4 p-3">ğŸ“š ì†Œì„¤ êµ¬ì„± ìš”ì†Œ ê´€ë¦¬ (GPT ìë™ ì •ë¦¬)</h1>

        <!-- ì†Œì„¤ ì œëª© ë° ì±•í„° êµ¬ì„± ì„¹ì…˜ -->
        <div class="card mb-3" style="border-radius: 0;">
            <div class="card-header bg-primary text-white d-flex justify-content-between align-items-center">
                <h5 class="mb-0">ğŸ“– ì†Œì„¤ ì œëª© ë° ì±•í„° êµ¬ì„±</h5>
                <button id="saveNovelConfigBtn" class="btn btn-sm btn-light">ğŸ’¾ ì €ì¥</button>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-4 mb-3">
                        <label class="form-label fw-bold">ì†Œì„¤ ì œëª©</label>
                        <input 
                            type="text" 
                            id="novelTitle" 
                            class="form-control" 
                            placeholder="ì†Œì„¤ ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš”"
                            list="novelTitleList"
                        >
                        <datalist id="novelTitleList"></datalist>
                        <div class="mt-2">
                            <small class="text-muted">
                                <strong>BIT MAX:</strong> <span id="novelTitleBitMax">-</span><br>
                                <strong>BIT MIN:</strong> <span id="novelTitleBitMin">-</span>
                            </small>
                        </div>
                    </div>
                    <div class="col-md-8">
                        <div class="d-flex justify-content-between align-items-center mb-2">
                            <label class="form-label fw-bold mb-0">ì±•í„° êµ¬ì„±</label>
                            <button id="addChapterBtn" class="btn btn-sm btn-success">â• ì±•í„° ì¶”ê°€</button>
                        </div>
                        <div class="mb-2">
                            <input
                                type="text"
                                id="chapterSearchInput"
                                class="form-control form-control-sm"
                                placeholder="ì±•í„° ë²ˆí˜¸/ì œëª©/ì„¤ëª…ìœ¼ë¡œ ê²€ìƒ‰ (ì‹¤ì‹œê°„)"
                            >
                        </div>
                        <div id="chaptersList" class="border rounded p-2" style="min-height: 100px; max-height: 300px; overflow-y: auto;">
                            <div class="text-muted text-center">ì±•í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ì±•í„°ë¥¼ ì¶”ê°€í•´ì£¼ì„¸ìš”.</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="row g-0">
            <!-- ì¢Œì¸¡: ì†ì„± ëª©ë¡ ì„¹ì…˜ -->
            <div class="col-md-3">
                <div class="card h-100" style="border-radius: 0;">
                    <div class="card-header bg-success text-white d-flex justify-content-between align-items-center">
                        <h5 class="mb-0">ğŸ“‹ ì €ì¥ëœ ì†ì„± ëª©ë¡</h5>
                        <div class="d-flex align-items-center gap-2">
                            <button id="collectAllDataBtn" class="btn btn-sm btn-warning">ğŸ“¥ ë¶„ì„ ì…ë ¥</button>
                            <button id="refreshBtn" class="btn btn-sm btn-light">ğŸ”„ ìƒˆë¡œê³ ì¹¨</button>
                        </div>
                    </div>
                    <div class="card-body" style="max-height: calc(100vh - 200px); overflow-y: auto;">
                        <!-- ì†ì„± ê²€ìƒ‰ í•„í„° -->
                        <div class="mb-3 pb-3 border-bottom">
                            <label class="form-label fw-bold small mb-1">ì†ì„± N/B AI í•„í„°</label>
                            <input 
                                type="text" 
                                id="attributeFilterInput" 
                                class="form-control form-control-sm" 
                                placeholder="ì†Œì„¤ ì œëª© ë° ì±•í„°ë¥¼ ì…ë ¥í•˜ì„¸ìš”... (ì˜ˆ: ë‹¤í¬ íŒíƒ€ì§€ â†’ ì±•í„° 1: ê°œìš”)"
                            >
                            <small class="text-muted">ì…ë ¥í•˜ë©´ ìë™ìœ¼ë¡œ ì†ì„± ëª©ë¡ì´ ë¶ˆëŸ¬ì™€ì§‘ë‹ˆë‹¤.</small>
                        </div>
                        
                        <!-- ì¶”ê°€ ê²€ìƒ‰ -->
                        <div class="mb-3 pb-3 border-bottom">
                            <label class="form-label fw-bold small mb-1">â• ì¶”ê°€ ê²€ìƒ‰ (ì„ íƒì‚¬í•­)</label>
                            <input 
                                type="text" 
                                id="additionalSearchInput" 
                                class="form-control form-control-sm" 
                                placeholder="ì‰¼í‘œë¡œ êµ¬ë¶„í•˜ì—¬ ì¶”ê°€ ê²€ìƒ‰ í‚¤ì›Œë“œë¥¼ ì…ë ¥í•˜ì„¸ìš”"
                            >
                            <small class="text-muted">ê¸°ë³¸ ê²€ìƒ‰ì–´ì— ì‰¼í‘œë¡œ êµ¬ë¶„ëœ í‚¤ì›Œë“œë¥¼ ê°ê° ì¶”ê°€í•˜ì—¬ ê²€ìƒ‰í•©ë‹ˆë‹¤.</small>
                        </div>
                        
                        <!-- ê²€ìƒ‰ ê²°ê³¼ í•„í„°ë§ -->
                        <div class="mb-3 pb-3 border-bottom">
                            <label class="form-label fw-bold small mb-1">ğŸ” ê²€ìƒ‰ ê²°ê³¼ í•„í„°ë§ (ì„ íƒì‚¬í•­)</label>
                            <input 
                                type="text" 
                                id="searchFilterInput" 
                                class="form-control form-control-sm" 
                                placeholder="ê²€ìƒ‰ ê²°ê³¼ë¥¼ ì¶”ê°€ë¡œ í•„í„°ë§í•  í‚¤ì›Œë“œë¥¼ ì…ë ¥í•˜ì„¸ìš”..."
                            >
                            <small class="text-muted">ê²€ìƒ‰ ê²°ê³¼ì—ì„œ ì´ í‚¤ì›Œë“œê°€ í¬í•¨ëœ í•­ëª©ë§Œ í‘œì‹œí•©ë‹ˆë‹¤.</small>
                        </div>
                        
                        <div id="attributesList"></div>
                    </div>
                </div>
            </div>

            <!-- ê°€ìš´ë°: GPT ë¶„ì„ ê²°ê³¼ -->
            <div class="col-md-6">
                <!-- GPT ë¶„ì„ ê²°ê³¼ -->
                <div class="card" id="gptResultCard" style="display: none; border-radius: 0;">
                    <div class="card-header bg-info text-white">
                        <h5 class="mb-0">ğŸ“‹ GPT ë¶„ì„ ê²°ê³¼</h5>
                    </div>
                    <div class="card-body">
                        <div id="gptResponse" class="mb-3 p-3 bg-light rounded" style="white-space: pre-wrap; max-height: 300px; overflow-y: auto;"></div>
                        <div id="extractedAttributes" class="mb-3"></div>
                    </div>
                </div>
            </div>

            <!-- ìš°ì¸¡: GPT ë¶„ì„ ì…ë ¥ ì„¹ì…˜ -->
            <div class="col-md-3">
                <!-- GPT ìë™ ë¶„ì„ ì„¹ì…˜ -->
                <div class="card h-100" style="border-radius: 0;">
                    <div class="card-header bg-gradient text-white" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                        <h5 class="mb-0">ğŸ¤– GPT AI ìë™ ì†ì„± ì¶”ì¶œ</h5>
                    </div>
                    <div class="card-body">
                        <div class="mb-3">
                            <label class="form-label fw-bold">ë¶„ì„í•  í…ìŠ¤íŠ¸ ì…ë ¥</label>
                            <textarea 
                                id="gptInput" 
                                class="form-control" 
                                placeholder="ì†Œì„¤ ê´€ë ¨ í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”. GPTê°€ ìë™ìœ¼ë¡œ ì†ì„±(ì†Œì„¤ êµ¬ì„± ìš”ì†Œ)ë“¤ì„ ì¶”ì¶œí•˜ê³  ì •ë¦¬í•©ë‹ˆë‹¤.&#10;ì˜ˆ: ì†Œì„¤ì˜ ë‚´ìš©, ë“±ì¥ì¸ë¬¼ ì„¤ëª…, ë°°ê²½ ì„¤ì •, ì£¼ìš” ì‚¬ê±´ ë“±..."
                                rows="6"
                            ></textarea>
                        </div>
                        <div class="mb-3">
                            <label class="form-label fw-bold">GPT ëª¨ë¸ ì„ íƒ</label>
                            <select id="gptModelSelect" class="form-select">
                                <optgroup label="1ï¸âƒ£ ìµœê³ ê¸‰ ì°½ì‘ìš© (ì„¸ê³„ê´€Â·ë¬˜ì‚¬Â·ê°ì • ì¤‘ì‹¬)">
                                    <option value="gpt-5-pro">gpt-5-pro - ì¥í¸ ìŠ¤í† ë¦¬ êµ¬ì¡°, ì¸ë¬¼ ì‹¬ë¦¬, ì„¸ê³„ê´€ ì¼ê´€ì„± (íŒíƒ€ì§€, SF, ì² í•™ì  ëŒ€ì‚¬, ì‹¬ë¦¬ê·¹)</option>
                                </optgroup>
                                <optgroup label="2ï¸âƒ£ ì¤‘Â·ì¥í¸ ì„œì‚¬ + ëŒ€ì‚¬ ì¤‘ì‹¬">
                                    <option value="gpt-5-mini">gpt-5-mini - ì†ë„ ë¹ ë¥´ê³ , ì„¤ì • ê¸°ì–µ ìœ ì§€ë ¥ ìš°ìˆ˜ (ìºë¦­í„° ì¤‘ì‹¬ íšŒí™”)</option>
                                    <option value="gpt-5-nano">gpt-5-nano - ì¤‘Â·ì¥í¸ ì„œì‚¬ ì¤‘ì‹¬</option>
                                </optgroup>
                                <optgroup label="3ï¸âƒ£ ê°ì •Â·ì‹œê°ì  ë¬˜ì‚¬ ê°•í™”í˜•">
                                    <option value="gpt-4o">gpt-4o - ë³´ì´ëŠ” ë“¯í•œ ë¬˜ì‚¬ì™€ ìŒì„±ì  ë¦¬ë“¬ ìš°ìˆ˜ (ì¹´ë©”ë¼ ì‹œì , ë¹›, ìƒ‰, ê°ì •ì˜ ì§ˆê°)</option>
                                    <option value="gpt-4o-mini" selected>gpt-4o-mini (ê¸°ë³¸) - ê°ì •Â·ì‹œê°ì  ë¬˜ì‚¬ ê°•í™”í˜•</option>
                                </optgroup>
                                <optgroup label="4ï¸âƒ£ ì´ˆê³ ì† ì´ˆì•ˆìš© / ì›¹ì†Œì„¤í˜•">
                                    <option value="gpt-4.1-mini">gpt-4.1-mini - ì§§ì€ ì±•í„°ë¥¼ ë¹ ë¥´ê²Œ ì—¬ëŸ¬ ë²„ì „ ìƒì„± (ë¼ì´íŠ¸ë…¸ë²¨, ì›¹ì†Œì„¤)</option>
                                </optgroup>
                                <optgroup label="5ï¸âƒ£ ì‹¤í—˜ì  ìŠ¤í† ë¦¬+AI ëŒ€í™”í˜•">
                                    <option value="gpt-5-chat-latest">gpt-5-chat-latest - ëŒ€í™”í˜• ì„œì‚¬ ì œì‘ì— ê°•í•¨ (AI ìºë¦­í„° ê°„ ëŒ€ì‚¬, N/B AI ë¡œë´‡/ì¸ê³µì§€ëŠ¥ ì£¼ì œ)</option>
                                </optgroup>
                                <optgroup label="ê¸°íƒ€">
                                    <option value="gpt-4-turbo">gpt-4-turbo (ê³ ì„±ëŠ¥)</option>
                                    <option value="gpt-4">gpt-4 (í‘œì¤€)</option>
                                    <option value="gpt-3.5-turbo">gpt-3.5-turbo (ê²½ëŸ‰)</option>
                                </optgroup>
                            </select>
                        </div>
                        <div class="mb-3">
                            <label class="form-label fw-bold">í”„ë¡¬í”„íŠ¸ ì…ë ¥ 1</label>
                            <textarea 
                                id="gptPrompt1" 
                                class="form-control mb-2" 
                                placeholder="GPTì—ê²Œ ì¶”ê°€ ì§€ì‹œì‚¬í•­ì„ ì…ë ¥í•˜ì„¸ìš”. ì˜ˆ: 'ì†ì„±ì„ ë” ì¶”ê°€í•´ì£¼ì„¸ìš”', 'ì†Œì„¤ì˜ ë“±ì¥ì¸ë¬¼ê³¼ ë°°ê²½ë§Œ ì¶”ì¶œí•´ì£¼ì„¸ìš”', 'ì¥ë¥´ì™€ ì£¼ì œë¡œ ë¶„ë¥˜í•´ì£¼ì„¸ìš”' ë“±..."
                                rows="2"
                            ></textarea>
                        </div>
                        <button id="analyzeBtn1" class="btn btn-primary btn-lg w-100 mb-3">
                            ğŸ” GPT AIë¡œ ë¶„ì„ (í”„ë¡¬í”„íŠ¸ 1)
                        </button>
                        <div class="mb-3">
                            <label class="form-label fw-bold">í”„ë¡¬í”„íŠ¸ ì…ë ¥ 2</label>
                            <textarea 
                                id="gptPrompt2" 
                                class="form-control mb-2" 
                                placeholder="GPTì—ê²Œ ì¶”ê°€ ì§€ì‹œì‚¬í•­ì„ ì…ë ¥í•˜ì„¸ìš”. ì˜ˆ: 'ê°œìš”ë¥¼ ì¨ë‹¬ë¼', 'ìƒì„¸í•˜ê²Œ êµ¬ì¡°í™”í•´ì„œ ì‘ì„±í•´ì£¼ì„¸ìš”' ë“±..."
                                rows="2"
                            ></textarea>
                        </div>
                        <div class="mb-3">
                            <label class="form-label fw-bold small mb-1">ì†ì„± (ìë™ ì…ë ¥)</label>
                            <input 
                                type="text" 
                                id="selectedAttributeInput" 
                                class="form-control form-control-sm" 
                                placeholder="GPT ë¶„ì„ í›„ ìë™ìœ¼ë¡œ ì…ë ¥ë©ë‹ˆë‹¤..."
                                readonly
                            >
                        </div>
                        <div class="mb-3">
                            <label class="form-label fw-bold small mb-1">GPT í”„ë¡¬í”„íŠ¸ ë¡œê·¸ (ë°ì´í„° ì œì™¸)</label>
                            <textarea 
                                id="gptPromptLog" 
                                class="form-control form-control-sm" 
                                placeholder="GPTì— ì „ë‹¬ëœ í”„ë¡¬í”„íŠ¸ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤ (ë°ì´í„° í•„ë“œëŠ” ì œì™¸)..."
                                rows="4"
                                readonly
                                style="font-family: monospace; font-size: 0.85em;"
                            ></textarea>
                        </div>
                        <button id="analyzeBtn2" class="btn btn-success btn-lg w-100">
                            ğŸ” GPT AIë¡œ ë¶„ì„ (í”„ë¡¬í”„íŠ¸ 2)
                        </button>
                        <div id="gptStatus" class="mt-2 small"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ë¡œê·¸ ì¶œë ¥ ì˜ì—­ -->
        <div class="log-container" id="logContainer"></div>

        <!-- ì±•í„° ì¶”ê°€/í¸ì§‘ ëª¨ë‹¬ -->
        <div class="modal fade" id="chapterModal" tabindex="-1">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="chapterModalTitle">ì±•í„° ì¶”ê°€</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                    </div>
                    <div class="modal-body">
                        <div class="mb-3">
                            <label class="form-label fw-bold">ì±•í„° ë²ˆí˜¸ ë˜ëŠ” ì´ë¦„</label>
                            <input 
                                type="text" 
                                id="chapterNumberInput" 
                                class="form-control" 
                                placeholder="ì˜ˆ: ì±•í„° 1, ì œ1ì¥ ë“±"
                            >
                        </div>
                        <div class="mb-3">
                            <label class="form-label fw-bold">ì±•í„° ì œëª©</label>
                            <input 
                                type="text" 
                                id="chapterTitleInput" 
                                class="form-control" 
                                placeholder="ì±•í„° ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš”"
                            >
                        </div>
                        <div class="mb-3">
                            <label class="form-label fw-bold">ì±•í„° ì„¤ëª… (ì„ íƒì‚¬í•­)</label>
                            <textarea 
                                id="chapterDescriptionInput" 
                                class="form-control" 
                                rows="3"
                                placeholder="ì±•í„°ì— ëŒ€í•œ ì„¤ëª…ì„ ì…ë ¥í•˜ì„¸ìš”"
                            ></textarea>
                        </div>
                        <div id="chapterModalStatus" class="small text-danger"></div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">ì·¨ì†Œ</button>
                        <button type="button" id="chapterModalSaveBtn" class="btn btn-primary">ì €ì¥</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- ì†ì„±ë³„ ë°ì´í„° ì¶”ê°€ ëª¨ë‹¬ -->
        <div class="modal fade" id="addDataModal" tabindex="-1">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">ë°ì´í„° ì¶”ê°€</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                    </div>
                    <div class="modal-body">
                        <div class="mb-3">
                            <label class="form-label fw-bold">ì†ì„±:</label>
                            <div id="modalAttributeName" class="fw-bold text-primary"></div>
                            <small class="text-muted">
                                BIT MAX: <span id="modalAttributeMax">-</span> | 
                                BIT MIN: <span id="modalAttributeMin">-</span>
                            </small>
                        </div>
                        <div class="mb-3">
                            <label class="form-label fw-bold">ë°ì´í„° ì¶”ê°€ (ì´ ì†ì„±ì— ì†í•˜ëŠ” êµ¬ì²´ì ì¸ ë‚´ìš©)</label>
                            <textarea 
                                id="newDataInput" 
                                class="form-control" 
                                rows="3"
                                placeholder="ì˜ˆ: 'ì£¼ì¸ê³µì˜ ë‚´ì  ê°ˆë“±', 'ë§ˆë²• ì„¸ê³„ì˜ ë²•ì¹™' ë“±..."
                            ></textarea>
                            <div class="row mt-2">
                                <div class="col-md-6">
                                    <div class="bit-display">
                                        <strong>ë°ì´í„° BIT MAX:</strong> <span id="newDataMax">-</span>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <div class="bit-display">
                                        <strong>ë°ì´í„° BIT MIN:</strong> <span id="newDataMin">-</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <button id="saveDataBtn" class="btn btn-success">ë°ì´í„° ì €ì¥</button>
                        <span id="saveDataStatus" class="ms-2 small"></span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- ë°ì´í„° ìˆ˜ì • ëª¨ë‹¬ -->
        <div class="modal fade" id="editDataModal" tabindex="-1">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">ë°ì´í„° ìˆ˜ì •</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                    </div>
                    <div class="modal-body">
                        <div class="mb-3">
                            <label class="form-label fw-bold">ì†ì„±:</label>
                            <div id="editModalAttributeName" class="fw-bold text-primary"></div>
                            <small class="text-muted">
                                ì†ì„± BIT MAX: <span id="editModalAttributeMax">-</span> | 
                                ì†ì„± BIT MIN: <span id="editModalAttributeMin">-</span>
                            </small>
                        </div>
                        <div class="mb-3">
                            <label class="form-label fw-bold">ê¸°ì¡´ ë°ì´í„° BIT:</label>
                            <small class="text-muted">
                                BIT MAX: <span id="editModalDataBitMax">-</span> | 
                                BIT MIN: <span id="editModalDataBitMin">-</span>
                            </small>
                        </div>
                        <div class="mb-3">
                            <label class="form-label fw-bold">ë°ì´í„° ìˆ˜ì •</label>
                            <textarea 
                                id="editDataInput" 
                                class="form-control" 
                                rows="5"
                                placeholder="ìˆ˜ì •í•  ë‚´ìš©ì„ ì…ë ¥í•˜ì„¸ìš”..."
                            ></textarea>
                            <div class="row mt-2">
                                <div class="col-md-6">
                                    <div class="bit-display">
                                        <strong>ìƒˆ ë°ì´í„° BIT MAX:</strong> <span id="editDataMax">-</span>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <div class="bit-display">
                                        <strong>ìƒˆ ë°ì´í„° BIT MIN:</strong> <span id="editDataMin">-</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <button id="updateDataBtn" class="btn btn-primary">ë°ì´í„° ìˆ˜ì •</button>
                        <span id="updateDataStatus" class="ms-2 small"></span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ìš°ì¸¡ í•˜ë‹¨ ì´ˆê¸°í™” ë²„íŠ¼ -->
    <button id="resetAllBtn" class="btn btn-danger btn-lg floating-reset" title="ëª¨ë“  ë°ì´í„° ì´ˆê¸°í™”">
        ğŸ—‘ ì´ˆê¸°í™”
    </button>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://xn--9l4b4xi9r.com/_8%EB%B9%84%ED%8A%B8/js/bitCalculation.js" defer></script>
    <script>
        // DOM ìš”ì†Œ
        const $novelTitle = document.getElementById('novelTitle');
        const $novelTitleList = document.getElementById('novelTitleList');
        const $novelTitleBitMax = document.getElementById('novelTitleBitMax');
        const $novelTitleBitMin = document.getElementById('novelTitleBitMin');
        const $addChapterBtn = document.getElementById('addChapterBtn');
        const $chaptersList = document.getElementById('chaptersList');
        const $chapterSearchInput = document.getElementById('chapterSearchInput');
        const $saveNovelConfigBtn = document.getElementById('saveNovelConfigBtn');
        
        const $gptPrompt1 = document.getElementById('gptPrompt1');
        const $gptPrompt2 = document.getElementById('gptPrompt2');
        const $gptInput = document.getElementById('gptInput');
        const $gptModelSelect = document.getElementById('gptModelSelect');
        const $analyzeBtn1 = document.getElementById('analyzeBtn1');
        const $analyzeBtn2 = document.getElementById('analyzeBtn2');
        const $gptStatus = document.getElementById('gptStatus');
        const $selectedAttributeInput = document.getElementById('selectedAttributeInput');
        const $gptPromptLog = document.getElementById('gptPromptLog');
        const $gptResultCard = document.getElementById('gptResultCard');
        const $gptResponse = document.getElementById('gptResponse');
        const $extractedAttributes = document.getElementById('extractedAttributes');

        const $attributesList = document.getElementById('attributesList');
        const $refreshBtn = document.getElementById('refreshBtn');
        const $collectAllDataBtn = document.getElementById('collectAllDataBtn');
        const $resetAllBtn = document.getElementById('resetAllBtn');
        const $attributeFilterInput = document.getElementById('attributeFilterInput');
        const $additionalSearchInput = document.getElementById('additionalSearchInput');
        const $searchFilterInput = document.getElementById('searchFilterInput');
        
        // ë¡œê·¸ ê´€ë ¨
        const $logContainer = document.getElementById('logContainer');
        const MAX_LOG_ENTRIES = 50;

        // ì±•í„° ê´€ë¦¬
        let chapters = [];
        let currentChapterIdx = null; // í˜„ì¬ ì„ íƒëœ ì±•í„° ì¸ë±ìŠ¤
        
        // localStorage í‚¤
        const STORAGE_KEY_NOVEL_TITLE = 'novel_composition_novel_title';
        const STORAGE_KEY_CHAPTERS = 'novel_composition_chapters';
        const STORAGE_KEY_CURRENT_CHAPTER = 'novel_composition_current_chapter';
        const STORAGE_KEY_CHAPTER_FILTER = 'novel_composition_chapter_filter';
        const STORAGE_KEY_TITLE_LIST = 'novel_composition_title_list';
        const STORAGE_KEY_CHAPTERS_BY_TITLE = 'novel_composition_chapters_by_title';
        
        // íƒ€ì´í‹€ ëª©ë¡ ë¡œë“œ/ì €ì¥ ìœ í‹¸
        function getSavedTitleList() {
            try {
                const raw = localStorage.getItem(STORAGE_KEY_TITLE_LIST);
                const list = raw ? JSON.parse(raw) : [];
                return Array.isArray(list) ? list : [];
            } catch { return []; }
        }
        function saveTitleList(list) {
            try {
                // ì •ê·œí™” ê¸°ì¤€ìœ¼ë¡œ ì¤‘ë³µ ì œê±°
                const seen = new Set();
                const deduped = [];
                list.forEach((t) => {
                    const k = normalizeTitleKey(t);
                    if (!seen.has(k)) { seen.add(k); deduped.push(t); }
                });
                localStorage.setItem(STORAGE_KEY_TITLE_LIST, JSON.stringify(deduped));
            } catch {}
        }
        function addTitleToList(title) {
            if (!title) return;
            const list = getSavedTitleList();
            const k = normalizeTitleKey(title);
            const existingIdx = list.findIndex(t => normalizeTitleKey(t) === k);
            if (existingIdx >= 0) list.splice(existingIdx, 1);
            list.unshift(title);
            saveTitleList(list.slice(0, 50));
            renderTitleDatalist();
        }
        function renderTitleDatalist() {
            if (!$novelTitleList) return;
            const list = getSavedTitleList();
            $novelTitleList.innerHTML = list.map(t => `<option value="${escapeHtml(t)}"></option>`).join('');
        }

        // localStorageì— ì†Œì„¤ ì œëª© ì €ì¥ + ëª©ë¡ ë°˜ì˜
        function saveNovelTitle() {
            const title = $novelTitle.value.trim();
            if (title) {
                localStorage.setItem(STORAGE_KEY_NOVEL_TITLE, title);
                addTitleToList(title);
                console.log('ì†Œì„¤ ì œëª© ì €ì¥:', title);
            } else {
                localStorage.removeItem(STORAGE_KEY_NOVEL_TITLE);
            }
        }
        
        // localStorageì— ì±•í„° ëª©ë¡ ì €ì¥
        function saveChapters() {
            try {
                console.log('saveChapters ì‹¤í–‰ ì‹œì‘', { chaptersCount: chapters.length, currentChapterIdx });
                const chaptersJson = JSON.stringify(chapters);
                localStorage.setItem(STORAGE_KEY_CHAPTERS, chaptersJson);
                localStorage.setItem(STORAGE_KEY_CURRENT_CHAPTER, String(currentChapterIdx));
                // íƒ€ì´í‹€ë³„ ì €ì¥
                const title = ($novelTitle.value || '').trim();
                if (title) {
                    try {
                        const raw = localStorage.getItem(STORAGE_KEY_CHAPTERS_BY_TITLE);
                        const map = raw ? JSON.parse(raw) : {};
                        const key = normalizeTitleKey(title);
                        map[key] = { title, chapters: deepClone(chapters), currentChapterIdx };
                        localStorage.setItem(STORAGE_KEY_CHAPTERS_BY_TITLE, JSON.stringify(map));
                        addTitleToList(title);
                    } catch (e) { console.warn('íƒ€ì´í‹€ë³„ ì €ì¥ ì‹¤íŒ¨:', e); }
                }
                console.log('ì±•í„° ëª©ë¡ ì €ì¥ ì™„ë£Œ:', { 
                    chaptersCount: chapters.length, 
                    currentChapterIdx,
                    saved: localStorage.getItem(STORAGE_KEY_CHAPTERS) ? 'ì„±ê³µ' : 'ì‹¤íŒ¨'
                });
            } catch (e) {
                console.error('saveChapters ì˜¤ë¥˜:', e);
            }
        }

        // íŠ¹ì • ì œëª© í‚¤ë¡œ í˜„ ìƒíƒœë¥¼ ì €ì¥
        function persistChaptersByTitle(titleKey) {
            try {
                const t = (titleKey || '').trim();
                if (!t) return;
                const raw = localStorage.getItem(STORAGE_KEY_CHAPTERS_BY_TITLE);
                const map = raw ? JSON.parse(raw) : {};
                const key = normalizeTitleKey(t);
                map[key] = { title: t, chapters: deepClone(chapters), currentChapterIdx };
                localStorage.setItem(STORAGE_KEY_CHAPTERS_BY_TITLE, JSON.stringify(map));
                console.log('íƒ€ì´í‹€ë³„ ì±•í„° ì €ì¥(ìš”ì²­):', t, { chaptersCount: chapters.length, currentChapterIdx });
            } catch (e) {
                console.warn('persistChaptersByTitle ì‹¤íŒ¨:', e);
            }
        }
        
        // localStorageì—ì„œ ì†Œì„¤ ì œëª© ë³µì›
        function loadNovelTitle() {
            const savedTitle = localStorage.getItem(STORAGE_KEY_NOVEL_TITLE);
            if (savedTitle) {
                $novelTitle.value = savedTitle;
                console.log('ì†Œì„¤ ì œëª© ë³µì›:', savedTitle);
            }
        }
        
        // localStorageì—ì„œ ì±•í„° ëª©ë¡ ë³µì›
        function loadChapters() {
            try {
                const title = ($novelTitle.value || '').trim();
                let loadedFromMap = false;
                if (title) {
                    try {
                        const raw = localStorage.getItem(STORAGE_KEY_CHAPTERS_BY_TITLE);
                        if (raw) {
                            const map = JSON.parse(raw);
                            const key = normalizeTitleKey(title);
                            const entry = (map && (map[key] || map[title])) || null; // êµ¬ë²„ì „ í˜¸í™˜
                            if (entry) {
                                chapters = Array.isArray(entry.chapters) ? deepClone(entry.chapters) : [];
                                currentChapterIdx = (typeof entry.currentChapterIdx === 'number') ? entry.currentChapterIdx : null;
                                loadedFromMap = true;
                                console.log('íƒ€ì´í‹€ë³„ ì±•í„° ë³µì›:', { title, chapters });
                            }
                        }
                    } catch (e) { console.warn('íƒ€ì´í‹€ë³„ ì±•í„° ë³µì› ì‹¤íŒ¨:', e); }
                }

                if (!loadedFromMap) {
                    if (title) {
                        // ì œëª©ì´ ìˆëŠ”ë° ë§¤í•‘ì´ ì—†ìœ¼ë©´ ë¹ˆ êµ¬ì„±ìœ¼ë¡œ ì´ˆê¸°í™”
                        chapters = [];
                        currentChapterIdx = null;
                        console.log('íƒ€ì´í‹€ ë§¤í•‘ ì—†ìŒ, ë¹ˆ êµ¬ì„±ìœ¼ë¡œ ì´ˆê¸°í™”:', title);
                        // ì´ˆê¸° ë§¤í•‘ì„ ìƒì„±í•´ ë‘ì–´ ì´í›„ ì €ì¥/ë³µì›ì´ ëª…í™•í•˜ë„ë¡ í•¨
                        persistChaptersByTitle(title);
                    } else {
                    const savedChapters = localStorage.getItem(STORAGE_KEY_CHAPTERS);
                    if (savedChapters) {
                        chapters = JSON.parse(savedChapters);
                        console.log('ì±•í„° ëª©ë¡ ë³µì›(êµ¬ë²„ì „):', chapters);
                    }
                    const savedCurrentChapter = localStorage.getItem(STORAGE_KEY_CURRENT_CHAPTER);
                    if (savedCurrentChapter !== null) {
                        const idx = parseInt(savedCurrentChapter);
                        if (idx >= 0 && idx < chapters.length) {
                            currentChapterIdx = idx;
                            console.log('ì„ íƒëœ ì±•í„° ë³µì›(êµ¬ë²„ì „):', idx);
                        }
                    }
                    }
                }
                
                renderChapters();
                // ì œëª© ê¸°ì¤€ìœ¼ë¡œ í•„í„°/ê²€ìƒ‰ ë“± ë™ê¸°í™”
                if (typeof syncFilterInputs === 'function') {
                    syncFilterInputs();
                }
            } catch (e) {
                console.error('ì±•í„° ë³µì› ì‹¤íŒ¨:', e);
            }
        }
        
        // ì±•í„° ëª©ë¡ ë Œë”ë§
        function renderChapters() {
            if (chapters.length === 0) {
                $chaptersList.innerHTML = '<div class="text-muted text-center">ì±•í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ì±•í„°ë¥¼ ì¶”ê°€í•´ì£¼ì„¸ìš”.</div>';
                return;
            }
            
            console.log('ì±•í„° ë Œë”ë§ ì‹œì‘', { chaptersCount: chapters.length, currentChapterIdx });
            
            // BIT ìŠ¤í¬ë¦½íŠ¸ê°€ ë¡œë“œë˜ì—ˆëŠ”ì§€ ë¨¼ì € í™•ì¸
            if (typeof wordNbUnicodeFormat === 'undefined' || typeof BIT_MAX_NB === 'undefined' || typeof BIT_MIN_NB === 'undefined') {
                console.log('BIT ìŠ¤í¬ë¦½íŠ¸ ë¡œë“œ ëŒ€ê¸° ì¤‘, ì ì‹œ í›„ ë‹¤ì‹œ ë Œë”ë§');
                setTimeout(() => renderChapters(), 200);
                return;
            }
            
            // í•„í„° í…ìŠ¤íŠ¸
            const filterText = ($chapterSearchInput && $chapterSearchInput.value || '').trim().toLowerCase();
            const matchesFilter = (ch) => {
                if (!filterText) return true;
                const num = (ch.number || '').toString().toLowerCase();
                const title = (ch.title || '').toString().toLowerCase();
                const desc = (ch.description || '').toString().toLowerCase();
                // 'ì œNì¥'ê³¼ 'ì±•í„° N' ìˆ«ì ì •ê·œí™” ë¹„êµ
                const digits = (s) => {
                    const m = s.match(/(\d{1,6})/);
                    return m ? m[1] : '';
                };
                const fDigits = digits(filterText);
                if (fDigits && (digits(num) === fDigits || digits(title) === fDigits)) return true;
                return num.includes(filterText) || title.includes(filterText) || desc.includes(filterText);
            };

            let html = '';
            chapters.forEach((chapter, idx) => {
                if (!matchesFilter(chapter)) return;
                // currentChapterIdxê°€ 0ì¼ ë•Œë„ ì„ íƒëœ ê²ƒìœ¼ë¡œ ì²˜ë¦¬ (ëª…ì‹œì ìœ¼ë¡œ !== null && !== undefined ì²´í¬)
                const isSelected = (currentChapterIdx !== null && currentChapterIdx !== undefined && currentChapterIdx === idx);
                console.log(`ì±•í„° ${idx} ì„ íƒ ìƒíƒœ:`, { isSelected, currentChapterIdx, idx, type: typeof currentChapterIdx });
                
                // ì±•í„° BIT ê³„ì‚° (ì±•í„° ë²ˆí˜¸ + ì œëª©)
                const chapterText = `${chapter.number || ''} ${chapter.title || ''}`.trim();
                let chapterBitMax = '-';
                let chapterBitMin = '-';
                
                if (chapterText) {
                    const chapterBits = calculateBitValues(chapterText);
                    chapterBitMax = chapterBits.max !== null && chapterBits.max !== undefined ? chapterBits.max.toFixed(15) : '-';
                    chapterBitMin = chapterBits.min !== null && chapterBits.min !== undefined ? chapterBits.min.toFixed(15) : '-';
                    console.log(`ì±•í„° ${idx} BIT ê³„ì‚°:`, { chapterText, bitMax: chapterBitMax, bitMin: chapterBitMin });
                }
                
                const chapterDisplay = `${escapeHtml(chapter.number || `ì±•í„° ${idx + 1}`)}: ${escapeHtml(chapter.title || '(ì œëª© ì—†ìŒ)')}`;
                const similarity = (filterText && chapterBits && filterBits && isFinite(chapterBits.max) && isFinite(chapterBits.min))
                    ? calculateBitPairSimilarity(filterBits, chapterBits)
                    : 0;
                const simBadge = filterText ? `<span class="badge ${similarity >= 0.9 ? 'bg-success' : similarity >= 0.7 ? 'bg-warning' : 'bg-info'} ms-2">ìœ ì‚¬ë„ ${(similarity * 100).toFixed(1)}%</span>` : '';

                html += `
                    <div class="d-flex align-items-center mb-2 p-2 border rounded chapter-item ${isSelected ? 'bg-primary text-white' : ''}" data-chapter-idx="${idx}">
                        <div class="flex-grow-1">
                            <div class="fw-bold">${chapterDisplay} ${simBadge}</div>
                            ${chapter.description ? `<div class="small ${isSelected ? 'text-white-50' : 'text-muted'} mt-1">${escapeHtml(chapter.description)}</div>` : ''}
                            <div class="small ${isSelected ? 'text-white-50' : 'text-muted'} mt-1">
                                <strong>BIT MAX:</strong> ${chapterBitMax} | 
                                <strong>BIT MIN:</strong> ${chapterBitMin}
                            </div>
                            ${chapter && chapter.published ? `<div class="small mt-1 ${isSelected ? 'text-warning' : 'text-warning'}"><strong>ğŸ“¢ ê²Œì‹œë¨</strong>${chapter.publishedAt ? ` Â· ${escapeHtml(new Date(chapter.publishedAt).toLocaleString())}` : ''}</div>` : ''}
                            ${isSelected ? '<div class="small mt-1" style="font-weight: bold; color: white;"><strong>âœ“ í˜„ì¬ ì‘ì—… ì¤‘ì¸ ì±•í„°</strong></div>' : ''}
                        </div>
                        <div class="ms-2">
                            <button class="btn btn-sm ${isSelected ? 'btn-light' : 'btn-outline-secondary'} copy-chapter-btn" data-idx="${idx}" title="ì±•í„° í…ìŠ¤íŠ¸ ë³µì‚¬">ğŸ“‹ ë³µì‚¬</button>
                            <button class="btn btn-sm ${isSelected ? 'btn-light' : 'btn-outline-success'} input-chapter-btn" data-idx="${idx}" title="ë¶„ì„ ì…ë ¥ìœ¼ë¡œ ë³´ë‚´ê¸°">â†˜ ì…ë ¥</button>
                            <button class="btn btn-sm ${isSelected ? 'btn-light' : 'btn-outline-primary'} select-chapter-btn" data-idx="${idx}">${isSelected ? 'âœ“ ì„ íƒë¨' : 'ì„ íƒ'}</button>
                            <button class="btn btn-sm ${isSelected ? 'btn-light' : 'btn-outline-primary'} edit-chapter-btn" data-idx="${idx}">âœï¸ í¸ì§‘</button>
                            <button class="btn btn-sm ${isSelected ? 'btn-outline-light' : 'btn-outline-danger'} delete-chapter-btn" data-idx="${idx}">ğŸ—‘ï¸ ì‚­ì œ</button>
                            ${chapter && chapter.published ? `<button class="btn btn-sm ${isSelected ? 'btn-warning' : 'btn-outline-warning'} analysis-to-input-btn" data-idx="${idx}">ğŸ“¥ ë¶„ì„ ì…ë ¥</button>` : ''}
                        </div>
                    </div>
                `;
            });
            $chaptersList.innerHTML = html;
            
            // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
            $chaptersList.querySelectorAll('.select-chapter-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const idx = parseInt(e.target.getAttribute('data-idx'));
                    selectChapter(idx);
                });
            });
            
            $chaptersList.querySelectorAll('.edit-chapter-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const idx = parseInt(e.target.getAttribute('data-idx'));
                    openEditChapterModal(idx);
                });
            });
            
            $chaptersList.querySelectorAll('.delete-chapter-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const idx = parseInt(e.target.getAttribute('data-idx'));
                    deleteChapter(idx);
                });
            });

            // ë³µì‚¬ ë²„íŠ¼
            $chaptersList.querySelectorAll('.copy-chapter-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    const idx = parseInt(btn.getAttribute('data-idx'));
                    if (idx >= 0 && idx < chapters.length) {
                        const ch = chapters[idx];
                        const text = `${ch.number || ''} ${ch.title || ''}\n${ch.description || ''}`.trim();
                        navigator.clipboard.writeText(text).then(() => {
                            console.log('ì±•í„° í…ìŠ¤íŠ¸ ë³µì‚¬ ì™„ë£Œ');
                        }).catch(() => {
                            console.warn('í´ë¦½ë³´ë“œ ë³µì‚¬ ì‹¤íŒ¨');
                        });
                    }
                });
            });

            // ì…ë ¥ ë²„íŠ¼ (ë¶„ì„ ì…ë ¥ìœ¼ë¡œ)
            $chaptersList.querySelectorAll('.input-chapter-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    const idx = parseInt(btn.getAttribute('data-idx'));
                    if (idx >= 0 && idx < chapters.length) {
                        const ch = chapters[idx];
                        const title = ($novelTitle && $novelTitle.value.trim()) || '';
                        const chapterLine = `${ch.number || ''}${ch.title ? `: ${ch.title}` : ''}`.trim();
                        const payload = [
                            title ? `ì†Œì„¤: ${title}` : '',
                            chapterLine ? `ì±•í„°: ${chapterLine}` : '',
                            ch.description ? `ì„¤ëª…: ${ch.description}` : ''
                        ].filter(Boolean).join('\n');
                        if ($gptInput) {
                            $gptInput.value = payload;
                            $gptInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                        if ($gptStatus) {
                            $gptStatus.textContent = 'âœ“ ì±•í„° ì •ë³´ê°€ ë¶„ì„ ì…ë ¥ë€ì— ì±„ì›Œì¡ŒìŠµë‹ˆë‹¤.';
                            $gptStatus.style.color = '#28a745';
                        }
                    }
                });
            });

            // ì±•í„° í´ë¦­ìœ¼ë¡œ ì„ íƒ (ë²„íŠ¼ í´ë¦­ì€ ì œì™¸)
            $chaptersList.querySelectorAll('.chapter-item').forEach(div => {
                div.addEventListener('click', (e) => {
                    if ((e.target && (e.target.closest('button') || e.target.tagName === 'BUTTON'))) return;
                    const idx = parseInt(div.getAttribute('data-chapter-idx'));
                    selectChapter(idx);
                });
            });

            // ê²Œì‹œëœ ì±•í„°ì˜ "ë¶„ì„ ì…ë ¥" ë²„íŠ¼ (ì €ì¥ëœ ë¶„ì„ í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥ë€ìœ¼ë¡œ)
            $chaptersList.querySelectorAll('.analysis-to-input-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    const idx = parseInt(btn.getAttribute('data-idx'));
                    analysisToInputFromChapter(idx);
                });
            });
        }
        
        // ì±•í„° ì„ íƒ
        function selectChapter(idx) {
            if (idx < 0 || idx >= chapters.length) {
                console.warn('ì˜ëª»ëœ ì±•í„° ì¸ë±ìŠ¤:', idx);
                return;
            }
            currentChapterIdx = idx;
            console.log('ì±•í„° ì„ íƒ:', { idx, currentChapterIdx, chapter: chapters[idx] });
            renderChapters();
            saveChapters(); // ìë™ ì €ì¥
            
            // í•„í„° ì…ë ¥ë€ì— ë™ê¸°í™”
            syncFilterInputs();
            
            // ì†ì„± ëª©ë¡ ìƒˆë¡œê³ ì¹¨ (ì„ íƒëœ ì±•í„° ê¸°ì¤€ìœ¼ë¡œ)
            if (chapters.length > 0) {
                loadAttributes();
            }
        }
        
        // í•„í„° ì…ë ¥ë€ì— ì†Œì„¤ ì œëª© ë° ì±•í„° ë™ê¸°í™”
        function syncFilterInputs() {
            if (!$attributeFilterInput) return;
            
            // ì†Œì„¤ ì œëª© ê°€ì ¸ì˜¤ê¸°
            const novelTitle = $novelTitle.value.trim();
            
            // ì„ íƒëœ ì±•í„° ì •ë³´ ê°€ì ¸ì˜¤ê¸°
            let chapterText = '';
            if (currentChapterIdx !== null && currentChapterIdx !== undefined && currentChapterIdx >= 0 && currentChapterIdx < chapters.length) {
                const selectedChapter = chapters[currentChapterIdx];
                chapterText = `${selectedChapter.number || `ì±•í„° ${currentChapterIdx + 1}`}${selectedChapter.title ? `: ${selectedChapter.title}` : ''}`;
            }
            
            // "ì†Œì„¤ ì œëª© â†’ ì±•í„° ë²ˆí˜¸: ì±•í„° ì œëª©" í˜•ì‹ìœ¼ë¡œ í†µí•©
            if (novelTitle && chapterText) {
                $attributeFilterInput.value = `${novelTitle} â†’ ${chapterText}`;
            } else if (novelTitle) {
                $attributeFilterInput.value = novelTitle;
            } else {
                $attributeFilterInput.value = '';
            }
            
            // ì†ì„± í•„í„° ë³€ê²½ ì‹œ ê²€ìƒ‰ ê²°ê³¼ í•„í„°ë§ ë™ê¸°í™”
            if (typeof syncAttributeFilterToSearchFilter === 'function') {
                syncAttributeFilterToSearchFilter();
            }
            
            console.log('í•„í„° ì…ë ¥ë€ ë™ê¸°í™”:', { novelTitle, chapterText, value: $attributeFilterInput.value });
        }
        
        // ì±•í„° ì¶”ê°€ ëª¨ë‹¬ ì—´ê¸°
        function openAddChapterModal() {
            editingChapterIdx = null;
            $chapterModalTitle.textContent = 'ì±•í„° ì¶”ê°€';
            const nextDefaults = computeNextChapterDefaults();
            $chapterNumberInput.value = nextDefaults.number;
            $chapterTitleInput.value = nextDefaults.title;
            $chapterDescriptionInput.value = '';
            $chapterModalStatus.textContent = '';
            ensureChapterModalAutoBtn();
            chapterModal.show();
        }
        
        // ì±•í„° í¸ì§‘ ëª¨ë‹¬ ì—´ê¸°
        function openEditChapterModal(idx) {
            if (idx < 0 || idx >= chapters.length) return;
            
            const chapter = chapters[idx];
            editingChapterIdx = idx;
            $chapterModalTitle.textContent = 'ì±•í„° í¸ì§‘';
            $chapterNumberInput.value = chapter.number || '';
            $chapterTitleInput.value = chapter.title || '';
            $chapterDescriptionInput.value = chapter.description || '';
            $chapterModalStatus.textContent = '';
            ensureChapterModalAutoBtn();
            chapterModal.show();
        }

        // ëª¨ë‹¬ì— GPT ìë™ ìƒì„± ë²„íŠ¼ ìƒì„± ë° í•¸ë“¤ëŸ¬ ì—°ê²° (ì¤‘ë³µ ìƒì„± ë°©ì§€)
        function ensureChapterModalAutoBtn() {
            try {
                const footer = document.querySelector('#chapterModal .modal-footer');
                if (!footer) return;
                if (!$chapterModalAutoBtn || !document.getElementById('chapterModalAutoBtn')) {
                    $chapterModalAutoBtn = document.createElement('button');
                    $chapterModalAutoBtn.type = 'button';
                    $chapterModalAutoBtn.className = 'btn btn-warning me-auto';
                    $chapterModalAutoBtn.id = 'chapterModalAutoBtn';
                    $chapterModalAutoBtn.textContent = 'ğŸ¤– ë‹¤ìŒ ì±•í„° ìë™ ìƒì„±';
                    footer.insertBefore($chapterModalAutoBtn, footer.firstChild);
                    $chapterModalAutoBtn.addEventListener('click', () => {
                        console.log('ë‹¤ìŒ ì±•í„° ìë™ ìƒì„± í´ë¦­');
                        generateNextChapterWithGPT();
                    });
                }
            } catch (e) {
                console.warn('ìë™ ìƒì„± ë²„íŠ¼ ì£¼ì… ì‹¤íŒ¨:', e);
            }
        }

        // GPTë¡œ ë‹¤ìŒ ì±•í„° ìë™ ìƒì„±
        async function generateNextChapterWithGPT() {
            try {
                $chapterModalStatus.textContent = 'GPTë¡œ ë‹¤ìŒ ì±•í„° ì œì•ˆ ìƒì„± ì¤‘...';
                $chapterModalStatus.style.color = '#007bff';

                const novelTitle = $novelTitle.value.trim();
                const lastChapter = chapters.length > 0 ? chapters[chapters.length - 1] : null;
                const lastPublished = [...chapters].reverse().find(ch => ch && ch.published && ch.analysisText);
                const contextText = (lastPublished && lastPublished.analysisText) ? lastPublished.analysisText
                    : ($gptInput.value.trim() || (lastChapter ? (lastChapter.description || '') : ''));

                // ê¸°ë³¸ ë²ˆí˜¸ ì œì•ˆ
                let nextNumber = '';
                let baseNum = chapters.length;
                if (lastChapter && lastChapter.number) {
                    const m = String(lastChapter.number).match(/(\d{1,4})/);
                    if (m && m[1]) {
                        const n = parseInt(m[1], 10);
                        if (!isNaN(n)) baseNum = n;
                    }
                }
                nextNumber = `ì±•í„° ${baseNum + 1}`;

                const systemMessage = 'ì†Œì„¤ ë‹¤ìŒ ì±•í„°ì˜ ì œëª©ê³¼ ì„¤ëª…ì„ ê°„ê²°íˆ ì œì•ˆí•˜ëŠ” ë„ìš°ë¯¸ì…ë‹ˆë‹¤. ë°˜ë“œì‹œ JSONë§Œ ë°˜í™˜í•©ë‹ˆë‹¤.';
                const nextDefaults = computeNextChapterDefaults();
                const userPrompt = `ë‹¤ìŒ ì •ë³´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ë‹¤ìŒ ì±•í„° ì œì•ˆì„ í•´ì£¼ì„¸ìš”. ë°˜ë“œì‹œ JSONë§Œ ë°˜í™˜í•˜ì„¸ìš”.\n\nì†Œì„¤: ${novelTitle || '(ì œëª© ë¯¸ì…ë ¥)'}\nì´ì „ ì±•í„°(ìµœê·¼) ë²ˆí˜¸/ì œëª©: ${lastChapter ? `${lastChapter.number || ''} ${lastChapter.title || ''}`.trim() : '(ì—†ìŒ)'}\nì»¨í…ìŠ¤íŠ¸(ìµœê·¼ ë¶„ì„/ìš”ì•½/ì„¤ëª… ì¤‘ í•˜ë‚˜):\n${contextText.substring(0, 2000)}\n\nìš”êµ¬ì‚¬í•­:\n- number: ë‹¤ìŒ ì±•í„° ë²ˆí˜¸ ë¬¸ìì—´(ì˜ˆ: "${nextNumber}")\n- title: ë‹¤ìŒ ì±•í„° ì œëª©(ì˜ˆ: "${nextDefaults.title || 'ì œ1ì¥'}" í˜•ì‹ ê¶Œì¥, 20ì ì´ë‚´ ê°„ê²°)\n- description: ë‚´ìš© ìš”ì•½ 2~4ë¬¸ì¥\n\nì¶œë ¥ ì˜ˆì‹œ: {"number":"${nextNumber}","title":"${nextDefaults.title || 'ì œ1ì¥'}","description":"..."}`;

                const url = getServerUrl('/api/gpt/chat');
                const res = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: userPrompt,
                        systemMessage: systemMessage,
                        model: 'gpt-4o-mini',
                        temperature: 0.5,
                        maxTokens: 400
                    })
                });
                if (!res.ok) {
                    const raw = await res.text().catch(() => '');
                    throw new Error(raw || `HTTP ${res.status}`);
                }
                const data = await res.json();
                if (!data.ok || !data.response) throw new Error(data.error || 'ì‘ë‹µ ì—†ìŒ');

                let jsonText = data.response.trim();
                if (jsonText.startsWith('```')) {
                    jsonText = jsonText.replace(/```json\s*/i, '').replace(/```$/i, '').trim();
                }
                let parsed = null;
                try {
                    parsed = JSON.parse(jsonText);
                } catch (e) {
                    const s = jsonText.indexOf('{');
                    const eIdx = jsonText.lastIndexOf('}');
                    if (s >= 0 && eIdx > s) parsed = JSON.parse(jsonText.substring(s, eIdx + 1));
                    else throw e;
                }

                const genNumber = (parsed.number || nextNumber).toString();
                let genTitle = (parsed.title || '').toString();
                if (!genTitle) {
                    const nd = computeNextChapterDefaults();
                    if (nd.title) genTitle = nd.title;
                }
                const genDesc = (parsed.description || '').toString();

                if (genNumber) $chapterNumberInput.value = genNumber;
                if (genTitle) $chapterTitleInput.value = genTitle;
                if (genDesc) $chapterDescriptionInput.value = genDesc;

                $chapterModalStatus.textContent = 'âœ“ ìë™ ìƒì„± ì™„ë£Œ. ë‚´ìš©ì„ í™•ì¸ í›„ ì €ì¥ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.';
                $chapterModalStatus.style.color = '#28a745';
            } catch (e) {
                console.error('ë‹¤ìŒ ì±•í„° ìë™ ìƒì„± ì˜¤ë¥˜:', e);
                $chapterModalStatus.textContent = `âœ— ìë™ ìƒì„± ì‹¤íŒ¨: ${e.message}`;
                $chapterModalStatus.style.color = '#dc3545';
            }
        }
        
        // ì±•í„° ì €ì¥ (ì¶”ê°€/í¸ì§‘)
        function saveChapter() {
            console.log('saveChapter í•¨ìˆ˜ í˜¸ì¶œë¨');
            try {
                const number = $chapterNumberInput.value.trim();
                const title = $chapterTitleInput.value.trim();
                const description = $chapterDescriptionInput.value.trim();
                
                console.log('ì…ë ¥ê°’ í™•ì¸:', { number, title, description });
                
                if (!number) {
                    $chapterModalStatus.textContent = 'ì±•í„° ë²ˆí˜¸ ë˜ëŠ” ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”.';
                    $chapterModalStatus.style.display = 'block';
                    console.warn('ì±•í„° ë²ˆí˜¸ ì—†ìŒ');
                    return;
                }
                
                if (!title) {
                    $chapterModalStatus.textContent = 'ì±•í„° ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš”.';
                    $chapterModalStatus.style.display = 'block';
                    console.warn('ì±•í„° ì œëª© ì—†ìŒ');
                    return;
                }
                
                $chapterModalStatus.textContent = '';
                $chapterModalStatus.style.display = 'none';
                
                const chapterData = {
                    number: number,
                    title: title,
                    description: description
                };
                
                if (editingChapterIdx !== null) {
                    // í¸ì§‘ - ê¸°ì¡´ í•„ë“œ(analysisText, published ë“±) ë³´ì¡´
                    const prev = chapters[editingChapterIdx] || {};
                    chapters[editingChapterIdx] = { ...prev, ...chapterData };
                    console.log('ì±•í„° í¸ì§‘:', { idx: editingChapterIdx, chapter: chapterData });
                } else {
                    // ì¶”ê°€
                    chapters.push({ ...chapterData, analysisText: '', published: false, publishedAt: '' });
                    console.log('ì±•í„° ì¶”ê°€:', chapterData);
                }
                
                console.log('ì±•í„° ëª©ë¡ ì—…ë°ì´íŠ¸ í›„:', chapters);
                renderChapters();
                
                console.log('saveChapters í•¨ìˆ˜ í˜¸ì¶œ ì‹œì‘');
                saveChapters(); // ìë™ ì €ì¥
                console.log('saveChapters í•¨ìˆ˜ í˜¸ì¶œ ì™„ë£Œ');
                
                // í•„í„° ì…ë ¥ë€ì— ë™ê¸°í™”
                syncFilterInputs();
                
                chapterModal.hide();
                console.log('ëª¨ë‹¬ ë‹«ê¸° ì™„ë£Œ');
            } catch (e) {
                console.error('saveChapter ì˜¤ë¥˜:', e);
                $chapterModalStatus.textContent = `ì˜¤ë¥˜: ${e.message}`;
                $chapterModalStatus.style.display = 'block';
            }
        }
        
        // ì±•í„° ì‚­ì œ
        function deleteChapter(idx) {
            if (idx < 0 || idx >= chapters.length) return;
            
            const chapter = chapters[idx];
            chapters.splice(idx, 1);
            
            // ì„ íƒëœ ì±•í„°ê°€ ì‚­ì œëœ ê²½ìš° ì¸ë±ìŠ¤ ì¡°ì •
            if (currentChapterIdx === idx) {
                currentChapterIdx = null;
            } else if (currentChapterIdx > idx) {
                currentChapterIdx--;
            }
            
            renderChapters();
            saveChapters(); // ìë™ ì €ì¥
            console.log('ì±•í„° ì‚­ì œ:', { idx, chapter: chapter });
            
            // ì†ì„± ëª©ë¡ ìƒˆë¡œê³ ì¹¨
            loadAttributes();
        }
        
        // ì±•í„° ì¶”ê°€ ë²„íŠ¼ ì´ë²¤íŠ¸
        $addChapterBtn.addEventListener('click', () => {
            console.log('ì±•í„° ì¶”ê°€ ë²„íŠ¼ í´ë¦­');
            openAddChapterModal();
        });

        // ì±•í„° ê²€ìƒ‰(ì‹¤ì‹œê°„)
        if ($chapterSearchInput) {
            // ë³µì›
            try {
                const saved = localStorage.getItem(STORAGE_KEY_CHAPTER_FILTER);
                if (saved) $chapterSearchInput.value = saved;
            } catch {}
            let chapterFilterTimer = null;
            $chapterSearchInput.addEventListener('input', () => {
                try { localStorage.setItem(STORAGE_KEY_CHAPTER_FILTER, $chapterSearchInput.value); } catch {}
                if (chapterFilterTimer) clearTimeout(chapterFilterTimer);
                chapterFilterTimer = setTimeout(() => {
                    renderChapters();
                }, 200);
            });
        }
        
        // ì†Œì„¤ ì œëª© ë° ì±•í„° êµ¬ì„± ì €ì¥ ë²„íŠ¼
        $saveNovelConfigBtn.addEventListener('click', () => {
            console.log('ì†Œì„¤ ì œëª© ë° ì±•í„° êµ¬ì„± ì €ì¥ ë²„íŠ¼ í´ë¦­');
            const novelTitle = $novelTitle.value.trim();
            
            if (!novelTitle) {
                alert('ì†Œì„¤ ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš”.');
                $novelTitle.focus();
                return;
            }
            
            if (chapters.length === 0) {
                const confirmAdd = confirm('ì±•í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ì±•í„°ë¥¼ ì¶”ê°€í•˜ì‹œê² ìŠµë‹ˆê¹Œ?');
                if (confirmAdd) {
                    openAddChapterModal();
                    return;
                }
            }
            
            // ì €ì¥ ì‹¤í–‰
            saveNovelTitle();
            saveChapters();
            
            // í”¼ë“œë°± í‘œì‹œ
            const originalText = $saveNovelConfigBtn.textContent;
            $saveNovelConfigBtn.textContent = 'âœ“ ì €ì¥ ì™„ë£Œ';
            $saveNovelConfigBtn.classList.remove('btn-light');
            $saveNovelConfigBtn.classList.add('btn-success');
            
            setTimeout(() => {
                $saveNovelConfigBtn.textContent = originalText;
                $saveNovelConfigBtn.classList.remove('btn-success');
                $saveNovelConfigBtn.classList.add('btn-light');
            }, 2000);
            
            console.log('ì†Œì„¤ ì œëª© ë° ì±•í„° êµ¬ì„± ì €ì¥ ì™„ë£Œ', { 
                novelTitle, 
                chaptersCount: chapters.length,
                currentChapterIdx 
            });
            addLog('info', `ì†Œì„¤ ì œëª© ë° ì±•í„° êµ¬ì„± ì €ì¥ ì™„ë£Œ: ${novelTitle} (ì±•í„° ${chapters.length}ê°œ)`);
        });
        
        // ì†Œì„¤ ì œëª© ì…ë ¥ ì‹œ BIT ê°’ ê³„ì‚° ë° í‘œì‹œ
        $novelTitle.addEventListener('input', () => {
            const title = $novelTitle.value.trim();
            updateNovelTitleBits(title);
            
            saveNovelTitle(); // ìë™ ì €ì¥
            
            // í•„í„° ì…ë ¥ë€ì— ë™ê¸°í™”
            syncFilterInputs();
            
            if (title) {
                loadAttributes();
            }
        });
        
        // ì†Œì„¤ ì œëª© BIT ê°’ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        function updateNovelTitleBits(title) {
            if (!title) {
                $novelTitleBitMax.textContent = '-';
                $novelTitleBitMin.textContent = '-';
                return;
            }
            
            // BIT ê³„ì‚° í•¨ìˆ˜ê°€ ë¡œë“œë˜ì—ˆëŠ”ì§€ í™•ì¸
            if (typeof wordNbUnicodeFormat === 'undefined' || typeof BIT_MAX_NB === 'undefined' || typeof BIT_MIN_NB === 'undefined') {
                // ì•„ì§ ë¡œë“œë˜ì§€ ì•ŠìŒ, ì ì‹œ í›„ ì¬ì‹œë„
                setTimeout(() => updateNovelTitleBits(title), 100);
                console.log('BIT ê³„ì‚° í•¨ìˆ˜ ë¡œë“œ ëŒ€ê¸° ì¤‘...');
                return;
            }
            
            const bits = calculateBitValues(title);
            $novelTitleBitMax.textContent = bits.max !== null && bits.max !== undefined ? bits.max.toFixed(15) : '-';
            $novelTitleBitMin.textContent = bits.min !== null && bits.min !== undefined ? bits.min.toFixed(15) : '-';
        }
        
        // ì†Œì„¤ ì œëª© ë³€ê²½ ì‹œ ì†ì„± ëª©ë¡ ìƒˆë¡œê³ ì¹¨
        $novelTitle.addEventListener('change', () => {
            const prevTitle = localStorage.getItem(STORAGE_KEY_NOVEL_TITLE) || '';
            // ê¸°ì¡´ ì œëª© êµ¬ì„±ì„ ë¨¼ì € ì•ˆì „í•˜ê²Œ ì €ì¥
            if (prevTitle) persistChaptersByTitle(prevTitle);
            // ìƒˆ ì œëª© ì €ì¥ ë° ëª©ë¡ ë°˜ì˜
            saveNovelTitle();
            // ìƒˆ ì œëª©ì— ë§ì¶˜ êµ¬ì„± ë¡œë“œ
            loadChapters();
            renderTitleDatalist();
            loadAttributes();
            if (typeof syncFilterInputs === 'function') {
                syncFilterInputs();
            }
        });

        // datalist ì„ íƒ ì‹œì—ë„ ë™ì‘ (input ì´ë²¤íŠ¸)
        $novelTitle.addEventListener('input', () => {
            const value = $novelTitle.value.trim();
            if (!value) return;
            const prevTitle = localStorage.getItem(STORAGE_KEY_NOVEL_TITLE) || '';
            const list = getSavedTitleList();
            const isKnown = list.some(t => normalizeTitleKey(t) === normalizeTitleKey(value));
            if (prevTitle !== value && isKnown) {
                if (prevTitle) persistChaptersByTitle(prevTitle);
                saveNovelTitle();
                loadChapters();
                renderTitleDatalist();
                loadAttributes();
                if (typeof syncFilterInputs === 'function') {
                    syncFilterInputs();
                }
            } else {
                // ëª©ë¡ì— ì—†ëŠ” ì¤‘ê°„ ì…ë ¥ì€ ì œëª©ë§Œ ì €ì¥(í•„í„° ë™ê¸°í™”ë§Œ)
                saveNovelTitle();
                if (typeof syncFilterInputs === 'function') {
                    syncFilterInputs();
                }
            }
        });

        // ë¡œê·¸ ì¶”ê°€ í•¨ìˆ˜
        function addLog(type, ...args) {
            const timestamp = new Date().toLocaleTimeString();
            let fullMessage = args.map(arg => {
                if (typeof arg === 'object') {
                    try {
                        return JSON.stringify(arg, null, 2);
                    } catch (e) {
                        return String(arg);
                    }
                }
                return String(arg);
            }).join(' ');

            // í‘œì‹œìš© ë©”ì‹œì§€ ê¸¸ì´ 50ìë¡œ ì œí•œ
            let displayMessage = fullMessage;
            const isTruncated = fullMessage.length > 50;
            if (isTruncated) {
                displayMessage = fullMessage.substring(0, 47) + '...';
            }

            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.setAttribute('data-full-message', fullMessage);
            logEntry.setAttribute('data-timestamp', timestamp);
            logEntry.setAttribute('data-type', type);
            
            const timeSpan = document.createElement('span');
            timeSpan.className = 'log-time';
            timeSpan.textContent = `[${timestamp}]`;
            
            const messageSpan = document.createElement('span');
            messageSpan.className = `log-message log-${type}`;
            messageSpan.textContent = displayMessage;
            
            logEntry.appendChild(timeSpan);
            logEntry.appendChild(messageSpan);
            
            // í´ë¦­ ì´ë²¤íŠ¸: ì „ì²´ ë©”ì‹œì§€ ë³´ê¸°
            if (isTruncated || fullMessage.length > 0) {
                logEntry.addEventListener('click', () => {
                    showLogDetail(fullMessage, timestamp, type);
                });
            }
            
            // prepend: ìƒˆ ë©”ì‹œì§€ë¥¼ ë§¨ ìœ„ì— ì¶”ê°€
            const firstChild = $logContainer.firstChild;
            if (firstChild) {
                $logContainer.insertBefore(logEntry, firstChild);
            } else {
                $logContainer.appendChild(logEntry);
            }
            
            // ìµœëŒ€ 50ê°œê¹Œì§€ë§Œ ìœ ì§€ (ë§¨ ì•„ë˜ë¶€í„° ì œê±°)
            const allEntries = $logContainer.querySelectorAll('.log-entry');
            if (allEntries.length > MAX_LOG_ENTRIES) {
                // ë§¨ ì•„ë˜(ê°€ì¥ ì˜¤ë˜ëœ) í•­ëª© ì œê±°
                const oldestEntry = allEntries[allEntries.length - 1];
                if (oldestEntry && oldestEntry.parentNode) {
                    oldestEntry.parentNode.removeChild(oldestEntry);
                }
            }
        }

        // ë¡œê·¸ ìƒì„¸ ë‚´ìš© í‘œì‹œ
        function showLogDetail(fullMessage, timestamp, type) {
            const typeLabels = {
                'message': 'ì •ë³´',
                'error': 'ì—ëŸ¬',
                'warn': 'ê²½ê³ ',
                'info': 'ì •ë³´'
            };
            
            // HTML ì´ìŠ¤ì¼€ì´í”„ í—¬í¼ í•¨ìˆ˜
            function escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
            
            const modal = document.createElement('div');
            modal.className = 'modal fade';
            modal.setAttribute('tabindex', '-1');
            
            const modalContent = document.createElement('div');
            modalContent.className = 'modal-dialog modal-lg';
            
            const content = document.createElement('div');
            content.className = 'modal-content bg-dark text-light';
            
            // í—¤ë”
            const header = document.createElement('div');
            header.className = 'modal-header border-secondary';
            header.innerHTML = `
                <h5 class="modal-title">ë¡œê·¸ ìƒì„¸ ë‚´ìš©</h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
            `;
            
            // ë°”ë””
            const body = document.createElement('div');
            body.className = 'modal-body';
            
            const timeDiv = document.createElement('div');
            timeDiv.className = 'mb-2';
            timeDiv.innerHTML = `<strong>ì‹œê°„:</strong> ${escapeHtml(timestamp)}`;
            
            const typeDiv = document.createElement('div');
            typeDiv.className = 'mb-2';
            typeDiv.innerHTML = `<strong>íƒ€ì…:</strong> <span class="log-${type}">${typeLabels[type] || type}</span>`;
            
            const labelDiv = document.createElement('div');
            labelDiv.className = 'mb-2';
            labelDiv.innerHTML = `<strong>ì „ì²´ ë©”ì‹œì§€:</strong>`;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = 'p-3 bg-black rounded';
            messageDiv.style.cssText = 'max-height: 400px; overflow-y: auto; font-family: monospace; white-space: pre-wrap; word-break: break-all; color: #0f0;';
            messageDiv.textContent = fullMessage;
            
            body.appendChild(timeDiv);
            body.appendChild(typeDiv);
            body.appendChild(labelDiv);
            body.appendChild(messageDiv);
            
            // í‘¸í„°
            const footer = document.createElement('div');
            footer.className = 'modal-footer border-secondary';
            
            const closeBtn = document.createElement('button');
            closeBtn.type = 'button';
            closeBtn.className = 'btn btn-secondary';
            closeBtn.setAttribute('data-bs-dismiss', 'modal');
            closeBtn.textContent = 'ë‹«ê¸°';
            
            footer.appendChild(closeBtn);
            
            content.appendChild(header);
            content.appendChild(body);
            content.appendChild(footer);
            modalContent.appendChild(content);
            modal.appendChild(modalContent);
            
            document.body.appendChild(modal);
            
            const bsModal = new bootstrap.Modal(modal);
            bsModal.show();
            
            // ëª¨ë‹¬ì´ ë‹«íˆë©´ DOMì—ì„œ ì œê±°
            modal.addEventListener('hidden.bs.modal', () => {
                if (modal.parentNode) {
                    document.body.removeChild(modal);
                }
            });
        }


        // console ë©”ì„œë“œ ì¸í„°ì…‰ì…˜
        (function() {
            const originalLog = console.log;
            const originalError = console.error;
            const originalWarn = console.warn;
            const originalInfo = console.info;

            console.log = function(...args) {
                originalLog.apply(console, args);
                addLog('message', ...args);
            };

            console.error = function(...args) {
                originalError.apply(console, args);
                addLog('error', ...args);
            };

            console.warn = function(...args) {
                originalWarn.apply(console, args);
                addLog('warn', ...args);
            };

            console.info = function(...args) {
                originalInfo.apply(console, args);
                addLog('info', ...args);
            };
        })();

        // ì „ì—­ ì—ëŸ¬ í•¸ë“¤ëŸ¬
        window.addEventListener('error', (event) => {
            console.error('ì „ì—­ ì—ëŸ¬:', event.error || event.message, event.filename, event.lineno);
        });

        window.addEventListener('unhandledrejection', (event) => {
            console.error('ì²˜ë¦¬ë˜ì§€ ì•Šì€ Promise ê±°ë¶€:', event.reason);
        });

        // Fetch ì—ëŸ¬ ì¸í„°ì…‰ì…˜ (ì„ íƒì )
        const originalFetch = window.fetch;
        window.fetch = async function(...args) {
            try {
                const response = await originalFetch.apply(this, args);
                return response;
            } catch (error) {
                console.error('Fetch ì—ëŸ¬:', error, args[0]);
                throw error;
            }
        };
        
        // ëª¨ë‹¬ ê´€ë ¨
        const chapterModal = new bootstrap.Modal(document.getElementById('chapterModal'));
        const $chapterModalTitle = document.getElementById('chapterModalTitle');
        const $chapterNumberInput = document.getElementById('chapterNumberInput');
        const $chapterTitleInput = document.getElementById('chapterTitleInput');
        const $chapterDescriptionInput = document.getElementById('chapterDescriptionInput');
        const $chapterModalSaveBtn = document.getElementById('chapterModalSaveBtn');
        const $chapterModalStatus = document.getElementById('chapterModalStatus');
        let $chapterModalAutoBtn = null; // GPT ìë™ ìƒì„± ë²„íŠ¼ ì°¸ì¡°
        let editingChapterIdx = null; // í¸ì§‘ ì¤‘ì¸ ì±•í„° ì¸ë±ìŠ¤
        
        // ì±•í„° ëª¨ë‹¬ ì €ì¥ ë²„íŠ¼ ì´ë²¤íŠ¸
        $chapterModalSaveBtn.addEventListener('click', () => {
            console.log('ì±•í„° ëª¨ë‹¬ ì €ì¥ ë²„íŠ¼ í´ë¦­ë¨');
            saveChapter();
        });
        
        // ëª¨ë‹¬ì—ì„œ Enter í‚¤ë¡œ ì €ì¥
        $chapterNumberInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                $chapterTitleInput.focus();
            }
        });
        
        $chapterTitleInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                saveChapter();
            }
        });
        
        $chapterDescriptionInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && e.ctrlKey) {
                e.preventDefault();
                saveChapter();
            }
        });
        
        const addDataModal = new bootstrap.Modal(document.getElementById('addDataModal'));
        const $modalAttributeName = document.getElementById('modalAttributeName');
        const $modalAttributeMax = document.getElementById('modalAttributeMax');
        const $modalAttributeMin = document.getElementById('modalAttributeMin');
        const $newDataInput = document.getElementById('newDataInput');
        const $newDataMax = document.getElementById('newDataMax');
        const $newDataMin = document.getElementById('newDataMin');
        const $saveDataBtn = document.getElementById('saveDataBtn');
        const $saveDataStatus = document.getElementById('saveDataStatus');
        
        const editDataModal = new bootstrap.Modal(document.getElementById('editDataModal'));
        const $editModalAttributeName = document.getElementById('editModalAttributeName');
        const $editModalAttributeMax = document.getElementById('editModalAttributeMax');
        const $editModalAttributeMin = document.getElementById('editModalAttributeMin');
        const $editModalDataBitMax = document.getElementById('editModalDataBitMax');
        const $editModalDataBitMin = document.getElementById('editModalDataBitMin');
        const $editDataInput = document.getElementById('editDataInput');
        const $editDataMax = document.getElementById('editDataMax');
        const $editDataMin = document.getElementById('editDataMin');
        const $updateDataBtn = document.getElementById('updateDataBtn');
        const $updateDataStatus = document.getElementById('updateDataStatus');
        
        // ìˆ˜ì •í•  ë°ì´í„° ì •ë³´ ì €ì¥
        let currentEditData = null;

        let currentAttribute = null;
        let extractedAttributesList = [];

        function getServerUrl(path) {
            if (window.location.protocol === 'file:') {
                return `http://localhost:8123${path}`;
            }
            return path;
        }

        // ì•ˆì „í•œ ë”¥í´ë¡  ìœ í‹¸
        function deepClone(obj) {
            try { return JSON.parse(JSON.stringify(obj)); } catch { return obj; }
        }

        // ì œëª© í‚¤ ì •ê·œí™”(ì–‘ë ê³µë°± ì œê±° + ë‚´ë¶€ ë‹¤ì¤‘ ê³µë°± 1ê°œë¡œ)
        function normalizeTitleKey(title) {
            return (title || '').toString().trim().replace(/\s+/g, ' ');
        }

        function calculateBitValues(text) {
            if (!text || typeof text !== 'string' || text.trim() === '') {
                return { max: null, min: null };
            }
            try {
                if (typeof wordNbUnicodeFormat === 'undefined' || typeof BIT_MAX_NB === 'undefined' || typeof BIT_MIN_NB === 'undefined') {
                    console.warn('BIT ê³„ì‚° í•¨ìˆ˜ê°€ ì•„ì§ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                    return { max: null, min: null };
                }
                const unicodeArray = wordNbUnicodeFormat(text);
                const max = BIT_MAX_NB(unicodeArray);
                const min = BIT_MIN_NB(unicodeArray);
                return { max: isFinite(max) ? max : null, min: isFinite(min) ? min : null };
            } catch (e) {
                console.error('BIT ê³„ì‚° ì˜¤ë¥˜:', e);
                return { max: null, min: null };
            }
        }

        // BIT ìœ ì‚¬ë„ ê³„ì‚° (0~1)
        function calculateBitPairSimilarity(filterBits, targetBits) {
            try {
                if (!filterBits || !targetBits) return 0;
                const fMax = Number(filterBits.max), fMin = Number(filterBits.min);
                const tMax = Number(targetBits.max), tMin = Number(targetBits.min);
                if (!isFinite(fMax) || !isFinite(fMin) || !isFinite(tMax) || !isFinite(tMin)) return 0;
                const dMax = Math.abs(fMax - tMax);
                const dMin = Math.abs(fMin - tMin);
                // ì •ê·œí™” ê¸°ì¤€ê°’ (ê²½í—˜ì¹˜ë¡œ ìŠ¤ì¼€ì¼)
                const norm = 5; // ì°¨ì´ê°€ 0ì´ë©´ 1, 5 ì´ìƒì´ë©´ 0 ê·¼ì²˜
                const simMax = Math.max(0, 1 - (dMax / norm));
                const simMin = Math.max(0, 1 - (dMin / norm));
                return Math.max(0, Math.min(1, (simMax * 0.6 + simMin * 0.4)));
            } catch { return 0; }
        }

        // ë‹¤ìŒ ì±•í„° ê¸°ë³¸ê°’ ê³„ì‚°: ë²ˆí˜¸(ì±•í„° N), ì œëª©(ì œNì¥ íŒ¨í„´ ì¶”ë¡ )
        function computeNextChapterDefaults() {
            // 1) ë‹¤ìŒ ë²ˆí˜¸: í˜„ì¬ ì±•í„°ë“¤ì˜ numberì—ì„œ ìˆ«ì ìµœëŒ€ê°’+1, ì—†ìœ¼ë©´ length+1
            let maxNum = 0;
            chapters.forEach((ch, idx) => {
                let n = 0;
                const m = (ch.number || '').toString().match(/(\d{1,6})/);
                if (m && m[1]) n = parseInt(m[1], 10) || 0;
                else n = idx + 1; // fallback: ë°°ì—´ ìˆœì„œ ê¸°ë°˜
                if (!isNaN(n)) maxNum = Math.max(maxNum, n);
            });
            if (maxNum === 0) maxNum = chapters.length; // ì™„ì „ ë¹ˆ number ì²˜ë¦¬
            const nextNumber = `ì±•í„° ${maxNum + 1}`;

            // 2) ë‹¤ìŒ ì œëª©: ê°€ì¥ í° chapter numberë¥¼ ê°€ì§„ í•­ëª©ì˜ ì œëª©ì„ ê¸°ì¤€ìœ¼ë¡œ +1
            let highestIdx = -1;
            let highestNum = -1;
            chapters.forEach((ch, idx) => {
                const m = (ch.number || '').toString().match(/(\d{1,6})/);
                const n = m && m[1] ? parseInt(m[1], 10) : (idx + 1);
                if (!isNaN(n) && n > highestNum) { highestNum = n; highestIdx = idx; }
            });

            let baseOrdinal = 0;
            if (highestIdx >= 0) {
                const t = (chapters[highestIdx].title || '').toString();
                const tm = t.match(/^\s*ì œ\s*(\d{1,6})\s*ì¥\s*$/);
                if (tm && tm[1]) baseOrdinal = parseInt(tm[1], 10) || 0;
            }
            // ë³´ì¡°: ì „ì²´ì—ì„œ ìµœëŒ€ 'ì œNì¥' íƒìƒ‰
            if (baseOrdinal === 0) {
                chapters.forEach(ch => {
                    const tm = (ch.title || '').toString().match(/^\s*ì œ\s*(\d{1,6})\s*ì¥\s*$/);
                    if (tm && tm[1]) {
                        const n = parseInt(tm[1], 10) || 0;
                        if (!isNaN(n)) baseOrdinal = Math.max(baseOrdinal, n);
                    }
                });
            }
            const nextTitle = baseOrdinal > 0 ? `ì œ${baseOrdinal + 1}ì¥` : '';

            return { number: nextNumber, title: nextTitle };
        }

        // ë§ˆí¬ë‹¤ìš´ ë¬¸ì ì œê±° í•¨ìˆ˜ (ì•ˆì „í•œ ë°©ì‹ - í…ìŠ¤íŠ¸ ë‚´ìš© ì†ìƒ ë°©ì§€)
        function removeMarkdownChars(text) {
            if (!text || typeof text !== 'string') {
                return text;
            }
            
            // ë¨¼ì € ì¤„ë³„ë¡œ ì²˜ë¦¬í•˜ì—¬ í—¤ë”ë§Œ ì •í™•íˆ ì œê±°
            let lines = text.split('\n');
            lines = lines.map(line => {
                // ì¤„ ì‹œì‘ì— ìˆëŠ” í—¤ë”ë§Œ ì œê±° (#ìœ¼ë¡œ ì‹œì‘í•˜ê³  ê³µë°±ì´ ë’¤ë”°ë¥´ëŠ” ê²½ìš°ë§Œ)
                if (/^#{1,6}\s+/.test(line)) {
                    return line.replace(/^#{1,6}\s+/, '');
                }
                return line;
            });
            
            let result = lines.join('\n');
            
            // ë³¼ë“œ/ì´íƒ¤ë¦­ì€ í…ìŠ¤íŠ¸ë¥¼ ê°ì‹¸ëŠ” ê²½ìš°ë§Œ ì œê±° (ë‹¨ë…ìœ¼ë¡œ ìˆëŠ” *ëŠ” ì œê±°í•˜ì§€ ì•ŠìŒ)
            // ***text*** í˜•íƒœ (ê³µë°± ì—†ëŠ” ê²½ìš°ë§Œ)
            result = result.replace(/\*\*\*([^*\s][^*]*?[^*\s])\*\*\*/g, '$1');
            // **text** í˜•íƒœ
            result = result.replace(/\*\*([^*\s][^*]*?[^*\s])\*\*/g, '$1');
            // *text* í˜•íƒœ (ë‹¨ì–´ë¥¼ ê°ì‹¸ëŠ” ê²½ìš°, ë‹¨ë… *ëŠ” ì œê±°í•˜ì§€ ì•ŠìŒ)
            result = result.replace(/\*([^\s*][^*]*?[^\s*])\*/g, '$1');
            
            // ì–¸ë”ìŠ¤ì½”ì–´ ë³¼ë“œ/ì´íƒ¤ë¦­ ì œê±° (í…ìŠ¤íŠ¸ë¥¼ ê°ì‹¸ëŠ” ê²½ìš°ë§Œ)
            result = result.replace(/__([^_]+?)__/g, '$1');
            result = result.replace(/\b_([^_\s]+?)_\b/g, '$1');
            
            // ì½”ë“œ ë¸”ë¡ ì œê±° (``` ë¡œ ì‹œì‘í•˜ê³  ```ë¡œ ëë‚˜ëŠ” ë¸”ë¡ë§Œ)
            result = result.replace(/```[\s\S]*?```/g, '');
            // ì¸ë¼ì¸ ì½”ë“œ ì œê±° (`ë¡œ ê°ì‹¼ ê²½ìš°ë§Œ)
            result = result.replace(/`([^`]+?)`/g, '$1');
            
            // ë§í¬ ì œê±° ([text](url))
            result = result.replace(/\[([^\]]+)\]\([^\)]+\)/g, '$1');
            // ì´ë¯¸ì§€ ì œê±° (![text](url))
            result = result.replace(/!\[([^\]]+)\]\([^\)]+\)/g, '$1');
            
            // ë‹¨ë…ìœ¼ë¡œ ìˆëŠ” ë§ˆí¬ë‹¤ìš´ ë¬¸ì ì œê±° (###, *** ë“±ì´ í˜¼ì ìˆëŠ” ê²½ìš°)
            result = result.replace(/^#{1,6}$/gm, '');
            result = result.replace(/^\*{1,3}$/gm, '');
            
            // ì¤„ë°”ê¿ˆ ì •ë¦¬
            result = result.replace(/\n{3,}/g, '\n\n');
            
            return result.trim();
        }

        // GPT ë¶„ì„ í•¨ìˆ˜
        async function analyzeWithGPT(customPrompt = null) {
            const text = $gptInput.value.trim();
            if (!text) {
                console.warn('GPT ë¶„ì„: ë¶„ì„í•  í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.');
                $gptStatus.textContent = 'âœ— ë¶„ì„í•  í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”.';
                $gptStatus.style.color = '#dc3545';
                return;
            }

            // í”„ë¡¬í”„íŠ¸ê°€ ì „ë‹¬ë˜ì§€ ì•Šìœ¼ë©´ ì²« ë²ˆì§¸ í”„ë¡¬í”„íŠ¸ ì‚¬ìš©
            if (customPrompt === null) {
                customPrompt = $gptPrompt1.value.trim();
            }

            // í”„ë¡¬í”„íŠ¸ ë¡œê·¸ ì¶œë ¥ (50ì ì œí•œ)
            const promptForLog = customPrompt && customPrompt.length > 50 
                ? customPrompt.substring(0, 47) + '...' 
                : customPrompt || '(ì—†ìŒ)';
            console.log('GPT ë¶„ì„ ì‹œì‘', `í”„ë¡¬í”„íŠ¸: ${promptForLog}`, `í…ìŠ¤íŠ¸ê¸¸ì´: ${text.length}`);

            try {
                // ë‘ ë²„íŠ¼ ëª¨ë‘ ë¹„í™œì„±í™”
                $analyzeBtn1.disabled = true;
                $analyzeBtn2.disabled = true;
                $gptStatus.textContent = 'GPT AI ë¶„ì„ ì¤‘...';
                $gptStatus.style.color = '#007bff';
                $gptResponse.textContent = 'ë¶„ì„ ì¤‘...';

                console.log('í”„ë¡¬í”„íŠ¸ ì„¤ì •', `í”„ë¡¬í”„íŠ¸: ${promptForLog}`);
                
                // ê°œìš” ìš”ì²­ í™•ì¸ (ë” ë„“ì€ ë²”ìœ„ë¡œ ê²€ìƒ‰)
                const lowerPrompt = customPrompt ? customPrompt.toLowerCase() : '';
                const isOutlineRequest = customPrompt && (
                    lowerPrompt.includes('ê°œìš”') || 
                    lowerPrompt.includes('ìƒì„¸') || 
                    lowerPrompt.includes('êµ¬ì¡°í™”') ||
                    lowerPrompt.includes('outline') ||
                    lowerPrompt.includes('ìš”ì•½') ||
                    lowerPrompt.includes('ì •ë¦¬')
                );
                
                console.log('ê°œìš” ìš”ì²­ í™•ì¸', { isOutlineRequest, customPrompt });
                
                const outlineInstructions = isOutlineRequest ? `

**âš ï¸ ì¤‘ìš”: ê°œìš” ì‘ì„± ëª¨ë“œ í™œì„±í™” âš ï¸**
ì‚¬ìš©ìê°€ "${customPrompt}"ë¼ê³  ìš”ì²­í–ˆìŠµë‹ˆë‹¤. ì´ë¥¼ ë°˜ë“œì‹œ ì¤€ìˆ˜í•˜ì„¸ìš”.

ê° ì†ì„±ì˜ "ë°ì´í„°" ë¶€ë¶„ì„ êµ¬ì¡°í™”ë˜ê³  ìƒì„¸í•œ ê°œìš” í˜•ì‹ìœ¼ë¡œ ì‘ì„±í•´ì£¼ì„¸ìš”:

- **ë“±ì¥ì¸ë¬¼ì˜ ê²½ìš°**: ê° ì¸ë¬¼ì˜ ì´ë¦„, ì—­í• , íŠ¹ì§•ì„ ëª…í™•íˆ êµ¬ë¶„í•˜ì—¬ ì‘ì„±
  ì˜ˆ: "ì¹´ì´ (ì£¼ì¸ê³µ): ì—˜í”„ ê°€ë“œì— í•©ë¥˜í•œ ì¸ë¬¼, ì •ì²´ì„±ì„ ì°¾ëŠ” ì¤‘ | ì„¸ë¦¬ì—˜: ë¦¬ë” ì—­í• , ê²½í—˜ ë§ì€ ì „ì‚¬ | ë¦¬ì•„ë‚˜: ì§€ì› ì—­í• , ë§ˆë²•ì‚¬..."

- **ë°°ê²½ ì„¤ì •ì˜ ê²½ìš°**: ì‹œê°„, ì¥ì†Œ, ì„¸ê³„ê´€ì„ êµ¬ë¶„í•˜ì—¬ ì‘ì„±
  ì˜ˆ: "ì‹œê°„: íŒíƒ€ì§€ ì‹œëŒ€ | ì¥ì†Œ: ì–´ë‘ìš´ ìˆ² | ì„¸ê³„ê´€: ì—˜í”„ ê°€ë“œì˜ ì „ì„¤ì´ ì¡´ì¬í•˜ëŠ” íŒíƒ€ì§€ ì„¸ê³„..."

- **ì£¼ìš” ì‚¬ê±´ì˜ ê²½ìš°**: ì‚¬ê±´ë“¤ì„ ì‹œê°„ìˆœ ë˜ëŠ” ì¤‘ìš”ë„ìˆœìœ¼ë¡œ ì •ë¦¬
  ì˜ˆ: "1. ì¹´ì´ê°€ ì—˜í”„ ê°€ë“œ ë¶€ëŒ€ì— í•©ë¥˜ | 2. ì „íˆ¬ì™€ ê°±í‚¹ ë°œìƒ | 3. ìì¹´ë¥´ì™€ì˜ ëŒ€ì¹˜ | 4. í¬í¬ë¦¬ì˜ ë“±ì¥ ë° í˜‘ë ¥..."

- **ê°ì •/ë¶„ìœ„ê¸°ì˜ ê²½ìš°**: ê°ì • ë³€í™”ì™€ ë¶„ìœ„ê¸°ë¥¼ êµ¬ì²´ì ìœ¼ë¡œ ì„¤ëª…
  ì˜ˆ: "ê¸´ì¥ê°: ì „íˆ¬ ìƒí™©ì—ì„œì˜ ë¶ˆì•ˆê° | í˜‘ë ¥: ìœ„ê¸° ìƒí™©ì—ì„œì˜ ì—°ëŒ€ê° | í˜¼ë€: ì˜ˆìƒì¹˜ ëª»í•œ ìƒí™©ì— ëŒ€í•œ ë‹¹í™©..."

- **í…Œë§ˆ/ì£¼ì œì˜ ê²½ìš°**: ì£¼ìš” ì£¼ì œì™€ í•˜ìœ„ ì£¼ì œë¥¼ êµ¬ë¶„
  ì˜ˆ: "- í˜‘ë ¥ê³¼ ë°°ì‹ : ë™ë£Œë“¤ ê°„ì˜ ì‹ ë¢° ê´€ê³„ | - ì •ì²´ì„±ì˜ íƒêµ¬: ì¹´ì´ì˜ ìê¸° ë°œê²¬ | - ì „ì„¤ê³¼ í˜„ì‹¤ì˜ ì¶©ëŒ: ì´ìƒê³¼ í˜„ì‹¤ì˜ ê°­..."

- **ìŠ¤íƒ€ì¼/í†¤ì˜ ê²½ìš°**: ë¬¸ì²´ íŠ¹ì§•ê³¼ í†¤ì„ êµ¬ì²´ì ìœ¼ë¡œ ì„¤ëª…
  ì˜ˆ: "ë¬¸ì²´: ì„œì‚¬ì  ë¬¸ì²´, ê¸´ì¥ê° ìˆëŠ” ì„œìˆ  | í†¤: íŒíƒ€ì§€ì  ìš”ì†Œ ê°•ì¡°, ì§„ì§€í•˜ê³  ëª°ì…ë„ ë†’ì€ ë¶„ìœ„ê¸°..."

**âš ï¸ ë°˜ë“œì‹œ ì¤€ìˆ˜**: ë°ì´í„° ë¶€ë¶„ì€ ë‹¨ìˆœ ë‚˜ì—´ì´ ì•„ë‹Œ êµ¬ì¡°í™”ëœ ê°œìš” í˜•ì‹ìœ¼ë¡œ ì‘ì„±í•˜ë˜, ë„ˆë¬´ ê¸¸ì§€ ì•Šê²Œ í•µì‹¬ë§Œ ê°„ê²°í•˜ê²Œ ì •ë¦¬í•´ì£¼ì„¸ìš”.
` : '';

                // í”„ë¡¬í”„íŠ¸ë¥¼ ì‹œìŠ¤í…œ ë©”ì‹œì§€ì™€ ì‚¬ìš©ì í”„ë¡¬í”„íŠ¸ ëª¨ë‘ì— ëª…í™•íˆ ë°˜ì˜
                const systemMessage = `ë‹¹ì‹ ì€ ì†Œì„¤ í…ìŠ¤íŠ¸ë¥¼ ë¶„ì„í•˜ì—¬ ì†Œì„¤ êµ¬ì„± ìš”ì†Œ(ì†ì„±)ë“¤ì„ ì¶”ì¶œí•˜ëŠ” ì „ë¬¸ê°€ì…ë‹ˆë‹¤.

ì…ë ¥ëœ í…ìŠ¤íŠ¸ë¥¼ ë¶„ì„í•˜ì—¬ ì†Œì„¤ì— í•„ìš”í•œ êµ¬ì„± ìš”ì†Œë“¤ì„ ì°¾ì•„ì£¼ì„¸ìš”. ì˜ˆë¥¼ ë“¤ì–´:
- ë“±ì¥ì¸ë¬¼ (ì£¼ì¸ê³µ, ì¡°ì—°, ì•…ì—­ ë“±)
- ë°°ê²½ ì„¤ì • (ì‹œê°„, ì¥ì†Œ, ì„¸ê³„ê´€)
- ì£¼ìš” ì‚¬ê±´ (í”Œë¡¯, ê°ˆë“±, ì „ê°œ)
- ê°ì •/ë¶„ìœ„ê¸° (ë¶„ìœ„ê¸°, ê°ì • ë³€í™”)
- í…Œë§ˆ/ì£¼ì œ (ë©”ì‹œì§€, êµí›ˆ)
- ìŠ¤íƒ€ì¼/í†¤ (ë¬¸ì²´, í†¤)

${customPrompt ? `\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
âš ï¸ ì‚¬ìš©ì ìš”ì²­ì‚¬í•­ (ë°˜ë“œì‹œ ì¤€ìˆ˜) âš ï¸
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
${customPrompt}

ìœ„ ìš”ì²­ì‚¬í•­ì„ ë°˜ë“œì‹œ ë°˜ì˜í•˜ì—¬ ì‘ë‹µí•´ì£¼ì„¸ìš”. ì´ ì§€ì‹œì‚¬í•­ì€ ë‹¤ë¥¸ ëª¨ë“  ì§€ì¹¨ë³´ë‹¤ ìš°ì„ í•©ë‹ˆë‹¤.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n` : ''}${outlineInstructions}

**ì‘ë‹µ í˜•ì‹**: ì•„ë˜ í˜•ì‹ì„ ì •í™•íˆ ë”°ë¥´ì„¸ìš”. ê° ì†ì„±ë§ˆë‹¤ ë‹¤ìŒê³¼ ê°™ì´ ì‘ì„±í•˜ì„¸ìš”:

ì†ì„± 1: [ì†ì„±ëª…]

ë°ì´í„°: ${isOutlineRequest ? '[âš ï¸ ìœ„ ê°œìš” ì‘ì„± ëª¨ë“œ ì§€ì¹¨ì„ ë°˜ë“œì‹œ ë”°ë¥´ì„¸ìš” - êµ¬ì¡°í™”ë˜ê³  ìƒì„¸í•œ ê°œìš” í˜•ì‹ìœ¼ë¡œ ì‘ì„±]' : '[êµ¬ì²´ì ì¸ ë°ì´í„° ë‚´ìš©]'}

ì´ìœ : [ì´ ì†ì„±ì„ ì¶”ì¶œí•œ ì´ìœ ]

ì†ì„± BIT: -, -

ë°ì´í„° BIT: -, -

---

ì†ì„± 2: [ì†ì„±ëª…]

ë°ì´í„°: ${isOutlineRequest ? '[âš ï¸ ìœ„ ê°œìš” ì‘ì„± ëª¨ë“œ ì§€ì¹¨ì„ ë°˜ë“œì‹œ ë”°ë¥´ì„¸ìš” - êµ¬ì¡°í™”ë˜ê³  ìƒì„¸í•œ ê°œìš” í˜•ì‹ìœ¼ë¡œ ì‘ì„±]' : '[êµ¬ì²´ì ì¸ ë°ì´í„° ë‚´ìš©]'}

ì´ìœ : [ì´ ì†ì„±ì„ ì¶”ì¶œí•œ ì´ìœ ]

ì†ì„± BIT: -, -

ë°ì´í„° BIT: -, -

---

(ê³„ì† ë°˜ë³µ...)

**ì¤‘ìš”**: 
- ìµœì†Œ 3ê°œ ì´ìƒì˜ ì†ì„±ì„ ì¶”ì¶œí•´ì£¼ì„¸ìš”.
- ì‚¬ìš©ìê°€ "ì†ì„±ì„ ë” ì¶”ê°€í•´ì£¼ì„¸ìš”" ë˜ëŠ” ìœ ì‚¬í•œ ìš”ì²­ì„ í•˜ë©´, ê¸°ì¡´ ì†ì„± ì™¸ì— ì¶”ê°€ ì†ì„±ë“¤ì„ ë” ì°¾ì•„ì„œ ì œê³µí•´ì£¼ì„¸ìš”.
- ì†ì„± BITì™€ ë°ì´í„° BITëŠ” í•­ìƒ "-, -"ë¡œ í‘œì‹œí•˜ì„¸ìš” (ì‹¤ì œ ê³„ì‚°ì€ ì‹œìŠ¤í…œì—ì„œ ì²˜ë¦¬í•©ë‹ˆë‹¤).
- JSON í˜•ì‹ì´ ì•„ë‹Œ ìœ„ì˜ í…ìŠ¤íŠ¸ í˜•ì‹ìœ¼ë¡œë§Œ ì‘ë‹µí•˜ì„¸ìš”.`;

                // í”„ë¡¬í”„íŠ¸ ì…ë ¥ì´ ìˆìœ¼ë©´ í•´ë‹¹ í”„ë¡¬í”„íŠ¸ ì‚¬ìš©, í…ìŠ¤íŠ¸ëŠ” ê·¸ëŒ€ë¡œ í¬í•¨
                // í”„ë¡¬í”„íŠ¸ì— {text} í”Œë ˆì´ìŠ¤í™€ë”ê°€ ìˆìœ¼ë©´ í…ìŠ¤íŠ¸ë¡œ ì¹˜í™˜, ì—†ìœ¼ë©´ í”„ë¡¬í”„íŠ¸ ë’¤ì— í…ìŠ¤íŠ¸ ì¶”ê°€
                let finalPrompt;
                if (customPrompt) {
                    // ì‚¬ìš©ì í”„ë¡¬í”„íŠ¸ë¥¼ ëª…í™•íˆ í‘œì‹œ
                    if (customPrompt.includes('{text}')) {
                        // í”„ë¡¬í”„íŠ¸ì— {text} í”Œë ˆì´ìŠ¤í™€ë”ê°€ ìˆìœ¼ë©´ ì¹˜í™˜
                        finalPrompt = customPrompt.replace(/{text}/g, text);
                    } else {
                        // í”Œë ˆì´ìŠ¤í™€ë”ê°€ ì—†ìœ¼ë©´ í”„ë¡¬í”„íŠ¸ë¥¼ ë¨¼ì € ëª…ì‹œí•˜ê³  í…ìŠ¤íŠ¸ ì¶”ê°€
                        finalPrompt = `${customPrompt}\n\n[ìœ„ ìš”ì²­ì‚¬í•­ì— ë”°ë¼ ì•„ë˜ í…ìŠ¤íŠ¸ë¥¼ ë¶„ì„í•´ì£¼ì„¸ìš”]\n\n${text}`;
                    }
                } else {
                    // ê¸°ë³¸ í”„ë¡¬í”„íŠ¸
                    finalPrompt = `ë‹¤ìŒ ì†Œì„¤ í…ìŠ¤íŠ¸ë¥¼ ë¶„ì„í•˜ì—¬ ì†Œì„¤ êµ¬ì„± ìš”ì†Œ(ì†ì„±)ë“¤ì„ ì¶”ì¶œí•´ì£¼ì„¸ìš”:\n\n"${text}"`;
                }

                // í”„ë¡¬í”„íŠ¸ 1ìš© ë¡œê·¸ ì €ì¥ (ë°ì´í„° ì œì™¸)
                updatePromptLog1(systemMessage, finalPrompt);

                const url = getServerUrl('/api/gpt/chat');
                console.log('GPT API ìš”ì²­ ì‹œì‘', { url, promptLength: finalPrompt.length });
                
                const selectedModel = $gptModelSelect ? $gptModelSelect.value : 'gpt-4o-mini';
                // í”„ë¡¬í”„íŠ¸ 1(ì†ì„± ì¶”ì¶œ)ì€ í•­ìƒ gpt-4o-mini ì‚¬ìš©
                const requestBody = {
                    prompt: finalPrompt,
                    systemMessage: systemMessage,
                    model: 'gpt-4o-mini',
                    temperature: 0.3,
                    maxTokens: 1500
                };
                
                const res = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                console.log('GPT API ì‘ë‹µ ìˆ˜ì‹ ', { status: res.status, statusText: res.statusText });

                if (!res.ok) {
                    // ì„œë²„ ì—ëŸ¬ ë©”ì‹œì§€ ì½ê¸° (ë³¸ë¬¸ì€ í•œ ë²ˆë§Œ ì½ëŠ”ë‹¤)
                    let errorMessage = `HTTP ${res.status}`;
                    const raw = await res.text().catch(() => '');
                    if (raw) {
                        try {
                            const errorData = JSON.parse(raw);
                            errorMessage = errorData.error || errorData.message || errorMessage;
                            console.error('GPT API ì˜¤ë¥˜ ìƒì„¸', { status: res.status, error: errorMessage, errorData });
                        } catch {
                            errorMessage = raw || errorMessage;
                            console.error('GPT API ì˜¤ë¥˜ (í…ìŠ¤íŠ¸)', { status: res.status, error: errorMessage });
                        }
                        if (errorMessage.includes('not supported') || errorMessage.includes('not in v1/chat/completions')) {
                            errorMessage = `ì„ íƒí•œ ëª¨ë¸ "${selectedModel}"ì€(ëŠ”) í˜„ì¬ APIì—ì„œ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë‹¤ë¥¸ ëª¨ë¸ì„ ì„ íƒí•´ì£¼ì„¸ìš”. (ê¶Œì¥: gpt-4o-mini, gpt-4o)`;
                        }
                    }
                    throw new Error(errorMessage);
                }

                const data = await res.json();
                console.log('GPT API ì‘ë‹µ íŒŒì‹± ì™„ë£Œ', { ok: data.ok, responseLength: data.response?.length || 0 });
                
                if (!data.ok) {
                    console.error('GPT ë¶„ì„ ì‹¤íŒ¨', { error: data.error });
                    throw new Error(data.error || 'GPT ë¶„ì„ ì‹¤íŒ¨');
                }

                console.log('GPT ì‘ë‹µ í…ìŠ¤íŠ¸ íŒŒì‹± ì‹œì‘');

                // í…ìŠ¤íŠ¸ í˜•ì‹ ì‘ë‹µ íŒŒì‹±
                let parsed = [];
                try {
                    const responseText = data.response.trim();
                    
                    // ë¨¼ì € JSON í˜•ì‹ì¸ì§€ í™•ì¸ (í•˜ìœ„ í˜¸í™˜ì„±ì„ ìœ„í•´)
                    let jsonText = responseText;
                    if (jsonText.startsWith('```json')) {
                        jsonText = jsonText.replace(/```json\s*/, '').replace(/\s*```$/, '');
                    } else if (jsonText.startsWith('```')) {
                        jsonText = jsonText.replace(/```\s*/, '').replace(/\s*```$/, '');
                    }
                    
                    try {
                        const jsonParsed = JSON.parse(jsonText);
                        if (Array.isArray(jsonParsed)) {
                            // JSON í˜•ì‹ìœ¼ë¡œ íŒŒì‹± ì„±ê³µ
                            parsed = jsonParsed.map(item => ({
                                attribute: item.attribute?.trim() || '',
                                data: item.data?.trim() || '',
                                reasoning: item.reasoning?.trim() || ''
                            }));
                        }
                    } catch {
                        // JSONì´ ì•„ë‹ˆë©´ í…ìŠ¤íŠ¸ í˜•ì‹ìœ¼ë¡œ íŒŒì‹±
                        // "ì†ì„± N: ..." íŒ¨í„´ìœ¼ë¡œ ì†ì„±ë“¤ì„ ë¶„ë¦¬
                        // "---" ë˜ëŠ” ë¹ˆ ì¤„ë¡œ êµ¬ë¶„ëœ ì„¹ì…˜ì„ ì°¾ìŒ
                        const sections = responseText.split(/(?:^|\n)---+|\n\n(?=ì†ì„±\s*\d+\s*:)/m);
                        
                        for (const section of sections) {
                            const trimmedSection = section.trim();
                            if (!trimmedSection) continue;
                            
                            // ì†ì„±ëª… ì¶”ì¶œ (ì†ì„± 1: ë˜ëŠ” ì†ì„± N: í˜•ì‹)
                            const attrMatch = trimmedSection.match(/ì†ì„±\s*\d+\s*:\s*(.+?)(?:\n|$)/);
                            if (!attrMatch) continue;
                            const attribute = attrMatch[1].trim();
                            
                            // ë°ì´í„° ì¶”ì¶œ (ë°ì´í„°: ë‹¤ìŒë¶€í„° ì´ìœ : ë˜ëŠ” ì†ì„± BIT: ì „ê¹Œì§€)
                            const dataMatch = trimmedSection.match(/ë°ì´í„°\s*:\s*(.+?)(?:\n\nì´ìœ :|\nì´ìœ :|\n\nì†ì„±\s*BIT:|\nì†ì„±\s*BIT:|$)/s);
                            const dataText = dataMatch ? dataMatch[1].trim() : '';
                            
                            // ì´ìœ  ì¶”ì¶œ (ì´ìœ : ë‹¤ìŒë¶€í„° ì†ì„± BIT: ë˜ëŠ” ë°ì´í„° BIT: ì „ê¹Œì§€)
                            const reasonMatch = trimmedSection.match(/ì´ìœ \s*:\s*(.+?)(?:\n\nì†ì„±\s*BIT:|\nì†ì„±\s*BIT:|\n\në°ì´í„°\s*BIT:|\në°ì´í„°\s*BIT:|$)/s);
                            const reasoning = reasonMatch ? reasonMatch[1].trim() : '';
                            
                            if (attribute && dataText) {
                                parsed.push({
                                    attribute: attribute,
                                    data: dataText,
                                    reasoning: reasoning
                                });
                            }
                        }
                        
                        // ì„¹ì…˜ ë¶„ë¦¬ê°€ ì•ˆ ëœ ê²½ìš°, ì§ì ‘ íŒ¨í„´ ë§¤ì¹­ ì‹œë„
                        if (parsed.length === 0) {
                            const attributeMatches = [...responseText.matchAll(/ì†ì„±\s*\d+\s*:\s*(.+?)(?:\n|$)/g)];
                            for (const attrMatch of attributeMatches) {
                                const attribute = attrMatch[1].trim();
                                if (!attribute) continue;
                                
                                // í•´ë‹¹ ì†ì„± ë‹¤ìŒ ë¶€ë¶„ ì°¾ê¸°
                                const attrIndex = attrMatch.index + attrMatch[0].length;
                                const nextSection = responseText.substring(attrIndex);
                                
                                const dataMatch = nextSection.match(/ë°ì´í„°\s*:\s*(.+?)(?:\n\nì´ìœ :|\nì´ìœ :|\n\nì†ì„±\s*BIT:|\nì†ì„±\s*BIT:|ì†ì„±\s*\d+\s*:|$)/s);
                                const dataText = dataMatch ? dataMatch[1].trim() : '';
                                
                                const reasonMatch = nextSection.match(/ì´ìœ \s*:\s*(.+?)(?:\n\nì†ì„±\s*BIT:|\nì†ì„±\s*BIT:|\n\në°ì´í„°\s*BIT:|\në°ì´í„°\s*BIT:|ì†ì„±\s*\d+\s*:|$)/s);
                                const reasoning = reasonMatch ? reasonMatch[1].trim() : '';
                                
                                if (attribute && dataText) {
                                    parsed.push({
                                        attribute: attribute,
                                        data: dataText,
                                        reasoning: reasoning
                                    });
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.error('íŒŒì‹± ì˜¤ë¥˜:', e);
                    throw new Error('GPT ì‘ë‹µ íŒŒì‹± ì‹¤íŒ¨: ' + e.message);
                }

                console.log('íŒŒì‹± ì™„ë£Œ', { parsedCount: parsed.length });

                if (!Array.isArray(parsed) || parsed.length === 0) {
                    console.error('ì†ì„± ì¶”ì¶œ ì‹¤íŒ¨: ì¶”ì¶œëœ ì†ì„±ì´ ì—†ìŠµë‹ˆë‹¤.');
                    throw new Error('GPT ì‘ë‹µì—ì„œ ì†ì„±ì„ ì¶”ì¶œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì‘ë‹µ í˜•ì‹ì„ í™•ì¸í•´ì£¼ì„¸ìš”.');
                }

                console.log('ì¶”ì¶œëœ ì†ì„± ì²˜ë¦¬ ì‹œì‘', { count: parsed.length });

                // ì¶”ì¶œëœ ì†ì„± ì²˜ë¦¬
                extractedAttributesList = parsed.map(item => {
                    const attribute = item.attribute?.trim() || '';
                    let dataText = item.data?.trim() || '';
                    const reasoning = item.reasoning?.trim() || '';
                    
                    // ë§ˆí¬ë‹¤ìš´ ë¬¸ì ì œê±°
                    dataText = removeMarkdownChars(dataText);
                    
                    if (!attribute || !dataText) {
                        return null;
                    }

                    const attrBits = calculateBitValues(attribute);
                    const dataBits = calculateBitValues(dataText);
                    
                    console.log('ì†ì„± BIT ê³„ì‚°', { 
                        attribute, 
                        attrBitMax: attrBits.max, 
                        attrBitMin: attrBits.min,
                        dataBitMax: dataBits.max,
                        dataBitMin: dataBits.min
                    });
                    
                    return {
                        attribute: attribute,
                        data: dataText,
                        reasoning: reasoning,
                        attributeBitMax: attrBits.max,
                        attributeBitMin: attrBits.min,
                        dataBitMax: dataBits.max,
                        dataBitMin: dataBits.min
                    };
                }).filter(Boolean);

                console.log('ì†ì„± ì²˜ë¦¬ ì™„ë£Œ', { validCount: extractedAttributesList.length });

                if (extractedAttributesList.length === 0) {
                    console.error('ìœ íš¨í•œ ì†ì„±ì´ ì—†ìŠµë‹ˆë‹¤.');
                    throw new Error('ì¶”ì¶œëœ ìœ íš¨í•œ ì†ì„±ì´ ì—†ìŠµë‹ˆë‹¤.');
                }

                // ê²°ê³¼ í‘œì‹œ
                console.log('ë¶„ì„ ê²°ê³¼ í‘œì‹œ', { attributeCount: extractedAttributesList.length });
                $gptResponse.textContent = data.response;
                displayExtractedAttributes();
                $gptResultCard.style.display = 'block';
                $gptStatus.textContent = `âœ“ ë¶„ì„ ì™„ë£Œ: ${extractedAttributesList.length}ê°œ ì†ì„± ì¶”ì¶œë¨. ìë™ ì €ì¥ ì¤‘...`;
                $gptStatus.style.color = '#007bff';

                // ìë™ ì €ì¥ ì‹¤í–‰
                console.log('ìë™ ì €ì¥ ì‹œì‘');
                await saveAllAttributes();
                console.log('GPT ë¶„ì„ ì™„ë£Œ');

            } catch (e) {
                console.error('GPT ë¶„ì„ ì˜¤ë¥˜:', e);
                $gptStatus.textContent = `âœ— ë¶„ì„ ì‹¤íŒ¨: ${e.message}`;
                $gptStatus.style.color = '#dc3545';
                $gptResponse.textContent = `ì˜¤ë¥˜: ${e.message}`;
            } finally {
                $analyzeBtn1.disabled = false;
                $analyzeBtn2.disabled = false;
            }
        }

        // ì¶”ì¶œëœ ì†ì„± í‘œì‹œ
        function displayExtractedAttributes() {
            let html = '<div class="row">';
            extractedAttributesList.forEach((item, idx) => {
                const attrMax = item.attributeBitMax !== null && item.attributeBitMax !== undefined ? item.attributeBitMax.toFixed(15) : '-';
                const attrMin = item.attributeBitMin !== null && item.attributeBitMin !== undefined ? item.attributeBitMin.toFixed(15) : '-';
                const dataMax = item.dataBitMax !== null && item.dataBitMax !== undefined ? item.dataBitMax.toFixed(15) : '-';
                const dataMin = item.dataBitMin !== null && item.dataBitMin !== undefined ? item.dataBitMin.toFixed(15) : '-';
                const saveStatus = item.saveStatus || 'pending'; // pending, saving, success, duplicate, error
                const saveMessage = item.saveMessage || '';
                
                let statusHtml = '';
                if (saveStatus === 'pending') {
                    statusHtml = '<div class="small text-muted mt-2"><em>ì €ì¥ ëŒ€ê¸° ì¤‘...</em></div>';
                } else if (saveStatus === 'saving') {
                    statusHtml = '<div class="small text-info mt-2">ğŸ’¾ ì €ì¥ ì¤‘...</div>';
                } else if (saveStatus === 'success') {
                    statusHtml = `<div class="small text-success mt-2">âœ“ ${saveMessage || 'ì €ì¥ ì™„ë£Œ'}</div>`;
                } else if (saveStatus === 'duplicate') {
                    // ì¤‘ë³µì´ê±°ë‚˜ ê¸°ì¡´ ë°ì´í„°ê°€ ìˆì„ ë•Œ ìˆ˜ì • ë²„íŠ¼ í‘œì‹œ
                    statusHtml = `
                        <div class="small text-warning mt-2 mb-2">âš  ${saveMessage || 'ê¸°ì¡´ ë°ì´í„°ê°€ ìˆìŠµë‹ˆë‹¤.'}</div>
                        <button class="btn btn-sm btn-warning" onclick="updateAttributeData(${idx}); return false;">
                            âœï¸ ìˆ˜ì •
                        </button>
                    `;
                } else if (saveStatus === 'error') {
                    statusHtml = `<div class="small text-danger mt-2">âœ— ${saveMessage || 'ì €ì¥ ì‹¤íŒ¨'}</div>`;
                }
                
                html += `
                    <div class="col-md-6 mb-3">
                        <div class="border rounded p-3 attribute-card" 
                             onclick="handleAttributeCardClick(${idx})">
                            <h6 class="text-primary">ì†ì„± ${idx + 1}: ${escapeHtml(item.attribute)}</h6>
                            <div class="mb-2">
                                <strong>ë°ì´í„°:</strong> ${escapeHtml(item.data)}
                            </div>
                            ${item.reasoning ? `<div class="small text-muted mb-2"><strong>ì´ìœ :</strong> ${escapeHtml(item.reasoning)}</div>` : ''}
                            <div class="small text-muted">
                                <strong>ì†ì„± BIT:</strong> MAX ${attrMax}, MIN ${attrMin}<br>
                                <strong>ë°ì´í„° BIT:</strong> MAX ${dataMax}, MIN ${dataMin}
                            </div>
                            ${(item.attributeBitMax === null || item.attributeBitMin === null || item.dataBitMax === null || item.dataBitMin === null) ? 
                                '<div class="text-warning small mt-1">âš  BIT ê°’ ê³„ì‚° ì‹¤íŒ¨</div>' : ''}
                            ${statusHtml}
                        </div>
                    </div>
                `;
            });
            html += '</div>';
            $extractedAttributes.innerHTML = html;
        }
        
        // ì†ì„± ì¹´ë“œ í´ë¦­ í•¸ë“¤ëŸ¬
        window.handleAttributeCardClick = function(idx) {
            const item = extractedAttributesList[idx];
            if (!item) return;
            
            // ì¢Œì¸¡ ì†ì„± ëª©ë¡ì—ì„œ í•´ë‹¹ ì†ì„± ì°¾ê¸°
            if (item.attributeBitMax && item.attributeBitMin) {
                scrollToAttribute(item.attributeBitMax, item.attributeBitMin, item.attribute);
            }
        };
        
        // ìˆ˜ì • ë²„íŠ¼ í´ë¦­ í•¸ë“¤ëŸ¬ (ì „ì—­ í•¨ìˆ˜ë¡œ ë“±ë¡)
        window.updateAttributeData = updateAttributeData;

        // ì¢Œì¸¡ ì†ì„± ëª©ë¡ì—ì„œ ì†ì„± ì°¾ì•„ì„œ ìŠ¤í¬ë¡¤í•˜ê³  ê°•ì¡° í‘œì‹œ
        function scrollToAttribute(bitMax, bitMin, attributeText) {
            console.log('ì†ì„± ìŠ¤í¬ë¡¤ ì‹œì‘', { attributeText, bitMax, bitMin });
            
            // ì´ì „ í•˜ì´ë¼ì´íŠ¸ ì œê±°
            const previousHighlighted = document.querySelector('.attribute-item.highlighted');
            if (previousHighlighted) {
                previousHighlighted.classList.remove('highlighted');
            }

            // ëª¨ë“  ì†ì„± ì•„ì´í…œ ì°¾ê¸°
            const attributeItems = document.querySelectorAll('.attribute-item');
            let targetElement = null;

            // BIT ê°’ìœ¼ë¡œ ì •í™•íˆ ì¼ì¹˜í•˜ëŠ” ì†ì„± ì°¾ê¸°
            attributeItems.forEach(item => {
                const bitMaxText = item.getAttribute('data-bit-max');
                const bitMinText = item.getAttribute('data-bit-min');
                
                if (bitMaxText && bitMinText) {
                    const itemBitMax = parseFloat(bitMaxText);
                    const itemBitMin = parseFloat(bitMinText);
                    
                    // BIT ê°’ì´ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸ (ì†Œìˆ˜ì  ì˜¤ì°¨ í—ˆìš©)
                    if (Math.abs(itemBitMax - bitMax) < 0.0001 && Math.abs(itemBitMin - bitMin) < 0.0001) {
                        targetElement = item;
                    }
                }
            });

            // BIT ê°’ìœ¼ë¡œ ëª» ì°¾ì•˜ìœ¼ë©´ í…ìŠ¤íŠ¸ë¡œ ì°¾ê¸°
            if (!targetElement) {
                attributeItems.forEach(item => {
                    // data-attribute-text ì†ì„±ìœ¼ë¡œ ì „ì²´ ì†ì„± í…ìŠ¤íŠ¸ í™•ì¸ (í”„ë¡¬í”„íŠ¸ 2 í˜•ì‹ ì§€ì›)
                    const dataAttributeText = item.getAttribute('data-attribute-text');
                    if (dataAttributeText && dataAttributeText.trim() === attributeText.trim()) {
                        targetElement = item;
                        return;
                    }
                    
                    // attribute-nameìœ¼ë¡œë„ í™•ì¸ (ë¶€ë¶„ ë§¤ì¹­)
                    const nameElement = item.querySelector('.attribute-name');
                    if (nameElement) {
                        const nameText = nameElement.textContent.trim();
                        // ì •í™•í•œ ì¼ì¹˜ ë˜ëŠ” ë¶€ë¶„ í¬í•¨ í™•ì¸
                        if (nameText === attributeText.trim() || attributeText.trim().includes(nameText) || nameText.includes(attributeText.trim())) {
                        targetElement = item;
                            return;
                        }
                    }
                });
            }

            if (targetElement) {
                console.log('ì†ì„± ì°¾ìŒ ë° ìŠ¤í¬ë¡¤', { attributeText });
                // í•˜ì´ë¼ì´íŠ¸ ì¶”ê°€
                targetElement.classList.add('highlighted');
                
                // ìŠ¤í¬ë¡¤í•˜ì—¬ í•´ë‹¹ ìš”ì†Œë¥¼ ë³´ì´ê²Œ í•¨
                targetElement.scrollIntoView({
                    behavior: 'smooth',
                    block: 'center'
                });

                // 3ì´ˆ í›„ í•˜ì´ë¼ì´íŠ¸ ì œê±°
                setTimeout(() => {
                    targetElement.classList.remove('highlighted');
                    console.log('ì†ì„± í•˜ì´ë¼ì´íŠ¸ ì œê±°', { attributeText });
                }, 3000);
            } else {
                console.warn('ì†ì„±ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤:', { attributeText, bitMax, bitMin });
                // ì†ì„± ëª©ë¡ì´ ë¹„ì–´ìˆê±°ë‚˜ ë¡œë”© ì¤‘ì¼ ë•Œë§Œ ìƒˆë¡œê³ ì¹¨
                if (attributeItems.length === 0) {
                    console.log('ì†ì„± ëª©ë¡ì´ ë¹„ì–´ìˆìŒ. ìƒˆë¡œê³ ì¹¨ í›„ ì¬ì‹œë„');
                loadAttributes().then(() => {
                        // ì¶©ë¶„í•œ ì‹œê°„ì„ ë‘ê³  ì¬ì‹œë„ (ë Œë”ë§ ì™„ë£Œ ëŒ€ê¸°)
                        setTimeout(() => {
                            scrollToAttribute(bitMax, bitMin, attributeText);
                        }, 800);
                    });
                } else {
                    console.warn('ì†ì„± ëª©ë¡ì— í•­ëª©ì´ ìˆì§€ë§Œ ì¼ì¹˜í•˜ëŠ” ì†ì„±ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                }
            }
        }


        // ì†ì„±ì— ê¸°ì¡´ ë°ì´í„°ê°€ ìˆëŠ”ì§€ í™•ì¸í•˜ëŠ” í•¨ìˆ˜ (gpt_auto_newì™€ ë™ì¼í•œ í•„í„°ë§)
        async function checkExistingData(attributeBitMax, attributeBitMin, novelTitle, currentChapter, attributeText = null, dataText = null) {
            try {
                // ì†ì„±ì˜ ë°ì´í„° ì¡°íšŒ
                const dataUrl = getServerUrl(`/api/attributes/data?bitMax=${attributeBitMax}&bitMin=${attributeBitMin}&limit=100`);
                const dataRes = await fetch(dataUrl);
                
                if (dataRes.ok) {
                    const dataData = await dataRes.json();
                    if (dataData.ok && dataData.items && dataData.items.length > 0) {
                        // gpt_auto_newì™€ ë™ì¼í•œ í•„í„°ë§: ì†ì„± í…ìŠ¤íŠ¸, ì†Œì„¤ ì œëª©, ì±•í„° ë²ˆí˜¸ì™€ ì œëª© ëª¨ë‘ ë¹„êµ
                        if (novelTitle && currentChapter) {
                            const filtered = dataData.items.filter(dataItem => {
                                // ì†ì„± í…ìŠ¤íŠ¸ê°€ ì œê³µëœ ê²½ìš° ì†ì„± í…ìŠ¤íŠ¸ ì •í™•íˆ ì¼ì¹˜í•´ì•¼ í•¨ (í•„ìˆ˜)
                                if (attributeText) {
                                    if (!dataItem.attribute || !dataItem.attribute.text) {
                                        return false; // ì†ì„± í…ìŠ¤íŠ¸ê°€ ì—†ìœ¼ë©´ ì œì™¸
                                    }
                                    const itemAttrText = dataItem.attribute.text.trim();
                                    const targetAttrText = attributeText.trim();
                                    if (itemAttrText !== targetAttrText) {
                                        return false; // ì†ì„± í…ìŠ¤íŠ¸ê°€ ë‹¤ë¥´ë©´ ì œì™¸
                                    }
                                } else {
                                    // attributeTextê°€ ì œê³µë˜ì§€ ì•Šì€ ê²½ìš°ë„ ì²´í¬
                                    return false; // ì†ì„± í…ìŠ¤íŠ¸ ì—†ì´ëŠ” ì¤‘ë³µ í™•ì¸ ë¶ˆê°€
                                }
                                
                                // ì†Œì„¤ ì œëª© ì •í™•íˆ ì¼ì¹˜
                                const novelMatch = dataItem.novel && 
                                                   dataItem.novel.title && 
                                                   dataItem.novel.title.trim() === novelTitle.trim();
                                if (!novelMatch) return false;
                                
                                // ì±•í„° ë²ˆí˜¸ ì •í™•íˆ ì¼ì¹˜
                                const chapterNumberMatch = dataItem.chapter && 
                                                          dataItem.chapter.number && 
                                                          dataItem.chapter.number.trim() === (currentChapter.number || '').trim();
                                if (!chapterNumberMatch) return false;
                                
                                // ì±•í„° ì œëª© ì •í™•íˆ ì¼ì¹˜ (ì œëª©ì´ ìˆëŠ” ê²½ìš°)
                                const chapterTitleMatch = !currentChapter.title || 
                                                          (dataItem.chapter && 
                                                           dataItem.chapter.title && 
                                                           dataItem.chapter.title.trim() === currentChapter.title.trim());
                                if (!chapterTitleMatch) return false;
                                
                                // ë°ì´í„° í…ìŠ¤íŠ¸ê°€ ì œê³µëœ ê²½ìš° ë°ì´í„° í…ìŠ¤íŠ¸ë„ ë¹„êµ (ê°™ì€ ì†ì„±ì— ê°™ì€ ë°ì´í„°ê°€ ìˆìœ¼ë©´ ì¤‘ë³µ)
                                if (dataText) {
                                    const existingDataText = dataItem.data?.text || dataItem.text || '';
                                    if (existingDataText.trim() === dataText.trim()) {
                                        // ê°™ì€ ì†ì„± + ê°™ì€ ë°ì´í„° = ì¤‘ë³µ
                                        return true;
                                    }
                                    // ì†ì„±ì€ ê°™ì§€ë§Œ ë°ì´í„°ê°€ ë‹¤ë¥´ë©´ ì¤‘ë³µ ì•„ë‹˜
                                    return false;
                                }
                                
                                // ë°ì´í„° í…ìŠ¤íŠ¸ ë¹„êµ ì—†ì´ ì†ì„±ë§Œ ì¼ì¹˜í•˜ë©´ ì¤‘ë³µìœ¼ë¡œ ê°„ì£¼
                                return true;
                            });
                            
                            console.log('ê¸°ì¡´ ë°ì´í„° í•„í„°ë§ ê²°ê³¼', {
                                totalItems: dataData.items.length,
                                filteredCount: filtered.length,
                                novelTitle,
                                currentChapter,
                                attributeText,
                                dataTextLength: dataText ? dataText.length : 0,
                                filteredItems: filtered.map(item => ({
                                    novel: item.novel?.title,
                                    chapter: `${item.chapter?.number}${item.chapter?.title ? ': ' + item.chapter.title : ''}`,
                                    attribute: item.attribute?.text,
                                    dataPreview: (item.data?.text || item.text || '').substring(0, 50)
                                }))
                            });
                            
                            return filtered.length > 0;
                        }
                        // ì†Œì„¤/ì±•í„° ì •ë³´ê°€ ì—†ìœ¼ë©´ ì†ì„± í…ìŠ¤íŠ¸ë§Œìœ¼ë¡œ ë¹„êµ
                        if (attributeText) {
                            const filtered = dataData.items.filter(dataItem => {
                                return dataItem.attribute && 
                                       dataItem.attribute.text && 
                                       dataItem.attribute.text.trim() === attributeText.trim();
                            });
                            return filtered.length > 0;
                        }
                        // ì†Œì„¤/ì±•í„° ì •ë³´ê°€ ì—†ê³  ì†ì„± í…ìŠ¤íŠ¸ë„ ì—†ìœ¼ë©´ ë°ì´í„°ê°€ ìˆìœ¼ë©´ true
                        return true;
                    }
                }
            } catch (e) {
                console.warn('ê¸°ì¡´ ë°ì´í„° í™•ì¸ ì˜¤ë¥˜:', e);
            }
            return false;
        }

        // ë‹¨ì¼ ì†ì„± ì—…ë°ì´íŠ¸ ì €ì¥ (ìˆ˜ì • ë²„íŠ¼ í´ë¦­ ì‹œ)
        async function updateAttributeData(idx) {
            const item = extractedAttributesList[idx];
            if (!item) return;
            
            try {
                item.saveStatus = 'saving';
                item.saveMessage = 'ìˆ˜ì • ì¤‘...';
                displayExtractedAttributes();
                
                // BIT ê°’ ê²€ì¦
                if (item.attributeBitMax === null || item.attributeBitMin === null || 
                    item.dataBitMax === null || item.dataBitMin === null) {
                    item.saveStatus = 'error';
                    item.saveMessage = 'BIT ê°’ ê³„ì‚° ì‹¤íŒ¨';
                    displayExtractedAttributes();
                    return;
                }

                const novelTitle = $novelTitle.value.trim();
                const currentChapter = currentChapterIdx !== null && chapters[currentChapterIdx] ? chapters[currentChapterIdx] : null;
                
                if (!novelTitle || !currentChapter) {
                    item.saveStatus = 'error';
                    item.saveMessage = 'ì†Œì„¤ ì œëª©ê³¼ ì±•í„°ë¥¼ ì„ íƒí•˜ì„¸ìš”.';
                    displayExtractedAttributes();
                    return;
                }

                // ì†Œì„¤ ì œëª© BIT ê³„ì‚°
                const novelTitleBits = calculateBitValues(novelTitle);
                const chapterText = `${currentChapter.number || ''} ${currentChapter.title || ''}`.trim();
                const chapterBits = calculateBitValues(chapterText);
                const chapterDisplay = `${currentChapter.number || ''}${currentChapter.title ? `: ${currentChapter.title}` : ''}`;
                const combinedAttributeText = `${novelTitle} â†’ ${chapterDisplay} â†’ ${item.attribute}`;
                const combinedAttributeBits = calculateBitValues(combinedAttributeText);
                
                // ê¸°ì¡´ ë°ì´í„° ì‚­ì œ í›„ ìƒˆë¡œ ì €ì¥ (ì†ì„±ë‹¹ 1ê°œë§Œ í—ˆìš©)
                // TODO: ê¸°ì¡´ ë°ì´í„° ì‚­ì œ APIê°€ í•„ìš”í•  ìˆ˜ ìˆìŒ, ì¼ë‹¨ ì €ì¥ ì‹œë„
                const url = getServerUrl('/api/attributes/data');
                const res = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        attributeBitMax: combinedAttributeBits.max,
                        attributeBitMin: combinedAttributeBits.min,
                        attributeText: combinedAttributeText,
                        text: item.data,
                        dataBitMax: item.dataBitMax,
                        dataBitMin: item.dataBitMin,
                        novelTitle: novelTitle,
                        novelTitleBitMax: novelTitleBits.max,
                        novelTitleBitMin: novelTitleBits.min,
                        chapter: currentChapter,
                        chapterBitMax: chapterBits.max,
                        chapterBitMin: chapterBits.min
                    })
                });

                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}`);
                }

                const data = await res.json();
                if (data.ok) {
                    item.saveStatus = 'success';
                    item.saveMessage = 'ìˆ˜ì • ì™„ë£Œ';
                    console.log(`ì†ì„± ìˆ˜ì • ì™„ë£Œ: ${item.attribute}`);
                } else {
                    throw new Error(data.error || 'ìˆ˜ì • ì‹¤íŒ¨');
                }
                
                displayExtractedAttributes();
                loadAttributes();
            } catch (e) {
                console.error(`ì†ì„± "${item.attribute}" ìˆ˜ì • ì˜¤ë¥˜:`, e);
                item.saveStatus = 'error';
                item.saveMessage = e.message || 'ìˆ˜ì • ì‹¤íŒ¨';
                displayExtractedAttributes();
            }
        }

        // ëª¨ë“  ì†ì„± ì €ì¥ (ìë™ ì €ì¥ - ì¤‘ë³µ/ë°ì´í„° ìˆìœ¼ë©´ ì €ì¥í•˜ì§€ ì•ŠìŒ)
        async function saveAllAttributes() {
            if (extractedAttributesList.length === 0) {
                console.warn('ì €ì¥í•  ì†ì„±ì´ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            console.log('ì†ì„± ì €ì¥ ì‹œì‘', { totalCount: extractedAttributesList.length });

            try {
                let successCount = 0;
                let duplicateCount = 0;
                let errorCount = 0;
                let skipCount = 0;

                // ê° ì†ì„±ë³„ë¡œ í™•ì¸ ë° ì €ì¥
                for (let idx = 0; idx < extractedAttributesList.length; idx++) {
                    const item = extractedAttributesList[idx];
                    
                    // ì´ˆê¸° ìƒíƒœë¡œ í‘œì‹œ
                    item.saveStatus = 'pending';
                    item.saveMessage = 'í™•ì¸ ì¤‘...';
                    displayExtractedAttributes();
                    
                    try {
                        // BIT ê°’ ê²€ì¦
                        if (item.attributeBitMax === null || item.attributeBitMin === null || 
                            item.dataBitMax === null || item.dataBitMin === null) {
                            item.saveStatus = 'error';
                            item.saveMessage = 'BIT ê°’ ê³„ì‚° ì‹¤íŒ¨';
                            errorCount++;
                            displayExtractedAttributes();
                            continue;
                        }

                        // ì†Œì„¤ ì œëª©ê³¼ ì±•í„° ì •ë³´ í™•ì¸
                        const novelTitle = $novelTitle.value.trim();
                        const currentChapter = currentChapterIdx !== null && chapters[currentChapterIdx] ? chapters[currentChapterIdx] : null;
                        
                        if (!novelTitle) {
                            console.warn('ì†Œì„¤ ì œëª©ì´ ì…ë ¥ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                            item.saveStatus = 'error';
                            item.saveMessage = 'ì†Œì„¤ ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš”.';
                            errorCount++;
                            displayExtractedAttributes();
                            continue;
                        }
                        
                        // ì†ì„±ëª… ì¡°í•© ë¡œì§ (ë¨¼ì € ì²˜ë¦¬í•˜ì—¬ ì†Œì„¤ ì œëª©/ì±•í„° ì •ë³´ íŒŒì‹±)
                        // í”„ë¡¬í”„íŠ¸ 2ì˜ ê²½ìš° item.attributeê°€ ì´ë¯¸ "ì†Œì„¤ ì œëª© â†’ ì±•í„°" í˜•ì‹ì¼ ìˆ˜ ìˆìŒ
                        const chapterDisplay = `${currentChapter.number || ''}${currentChapter.title ? `: ${currentChapter.title}` : ''}`;
                        let combinedAttributeText;
                        let finalNovelTitle = novelTitle;
                        let finalChapter = currentChapter;
                        
                        // í”„ë¡¬í”„íŠ¸ 2 í˜•ì‹ í™•ì¸ ë° íŒŒì‹±
                        const hasArrow = item.attribute.includes(' â†’ ');
                        const startsWithNovelTitle = item.attribute.trim().startsWith(novelTitle.trim());
                        
                        if (hasArrow && startsWithNovelTitle) {
                            // ì´ë¯¸ "ì†Œì„¤ ì œëª© â†’ ì±•í„°" í˜•ì‹ì´ë©´ ê·¸ëŒ€ë¡œ ì‚¬ìš© (í”„ë¡¬í”„íŠ¸ 2)
                            combinedAttributeText = item.attribute.trim();
                            
                            // ì†ì„± í…ìŠ¤íŠ¸ì—ì„œ ì†Œì„¤ ì œëª©ê³¼ ì±•í„° ì •ë³´ íŒŒì‹±
                            const parts = combinedAttributeText.split(' â†’ ');
                            if (parts.length >= 2) {
                                finalNovelTitle = parts[0].trim();
                                const chapterPart = parts[1].trim(); // "ì±•í„° 3: ì œ2ì¥"
                                
                                // ì±•í„° ì •ë³´ íŒŒì‹±
                                const chapterMatch = chapterPart.match(/^ì±•í„°\s*(\d+)(?:\s*:\s*(.+))?/);
                                if (chapterMatch) {
                                    const chapterNum = chapterMatch[1];
                                    const chapterTitle = chapterMatch[2] || '';
                                    
                                    // í˜„ì¬ ì±•í„° ëª©ë¡ì—ì„œ í•´ë‹¹ ì±•í„° ì°¾ê¸°
                                    const foundChapter = chapters.find(ch => 
                                        (ch.number || '').trim() === chapterNum && 
                                        (ch.title || '').trim() === chapterTitle.trim()
                                    );
                                    
                                    if (foundChapter) {
                                        finalChapter = foundChapter;
                                    } else {
                                        // ì±•í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìœ¼ë©´ ì„ì‹œ ê°ì²´ ìƒì„±
                                        finalChapter = { number: chapterNum, title: chapterTitle };
                                    }
                                }
                            }
                        } else {
                            // ì¼ë°˜ í˜•ì‹: "ì†Œì„¤ ì œëª© â†’ ì±•í„° â†’ ì†ì„±ëª…"
                            combinedAttributeText = `${novelTitle} â†’ ${chapterDisplay} â†’ ${item.attribute}`;
                            
                            // ì±•í„° ê²€ì¦
                            if (!finalChapter) {
                                console.warn('ì±•í„°ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                                item.saveStatus = 'error';
                                item.saveMessage = 'ì±•í„°ë¥¼ ì„ íƒí•˜ì„¸ìš”.';
                                errorCount++;
                                displayExtractedAttributes();
                                continue;
                            }
                        }

                        // ì†Œì„¤ ì œëª© BIT ê³„ì‚° (íŒŒì‹±ëœ ê°’ ì‚¬ìš©)
                        const novelTitleBits = calculateBitValues(finalNovelTitle);
                        if (novelTitleBits.max === null || novelTitleBits.min === null) {
                            console.warn('ì†Œì„¤ ì œëª© BIT ê³„ì‚° ì‹¤íŒ¨');
                            item.saveStatus = 'error';
                            item.saveMessage = 'ì†Œì„¤ ì œëª© BIT ê³„ì‚° ì‹¤íŒ¨';
                            errorCount++;
                            displayExtractedAttributes();
                            continue;
                        }

                        // ì±•í„° BIT ê³„ì‚° (ì±•í„° ë²ˆí˜¸ + ì œëª©ì„ ì¡°í•©, íŒŒì‹±ëœ ê°’ ì‚¬ìš©)
                        const chapterText = `${finalChapter.number || ''} ${finalChapter.title || ''}`.trim();
                        const chapterBits = calculateBitValues(chapterText);
                        if (chapterBits.max === null || chapterBits.min === null) {
                            console.warn('ì±•í„° BIT ê³„ì‚° ì‹¤íŒ¨');
                            item.saveStatus = 'error';
                            item.saveMessage = 'ì±•í„° BIT ê³„ì‚° ì‹¤íŒ¨';
                            errorCount++;
                            displayExtractedAttributes();
                            continue;
                        }
                        
                        // ì¡°í•©ëœ ì†ì„±ëª…ìœ¼ë¡œ BIT ê°’ ì¬ê³„ì‚°
                        const combinedAttributeBits = calculateBitValues(combinedAttributeText);
                        if (combinedAttributeBits.max === null || combinedAttributeBits.min === null) {
                            console.warn('ì¡°í•©ëœ ì†ì„±ëª… BIT ê³„ì‚° ì‹¤íŒ¨');
                            item.saveStatus = 'error';
                            item.saveMessage = 'ì†ì„±ëª… BIT ê³„ì‚° ì‹¤íŒ¨';
                            errorCount++;
                            displayExtractedAttributes();
                            continue;
                        }
                        
                        // ì €ì¥ ì „ì— ê¸°ì¡´ ë°ì´í„° í™•ì¸ (íŒŒì‹±ëœ ê°’ ì‚¬ìš©, gpt_auto_newì™€ ë™ì¼í•œ í•„í„°ë§)
                        const hasExistingData = await checkExistingData(
                            combinedAttributeBits.max,
                            combinedAttributeBits.min,
                            finalNovelTitle,
                            finalChapter,
                            combinedAttributeText,
                            item.data // ë°ì´í„° í…ìŠ¤íŠ¸ë„ ë¹„êµ
                        );
                        
                        if (hasExistingData) {
                            // ê¸°ì¡´ ë°ì´í„°ê°€ ìˆìœ¼ë©´ ì €ì¥í•˜ì§€ ì•Šê³  ì¤‘ë³µ ìƒíƒœë¡œ í‘œì‹œ
                            duplicateCount++;
                            item.saveStatus = 'duplicate';
                            item.saveMessage = 'ê¸°ì¡´ ë°ì´í„°ê°€ ìˆìŠµë‹ˆë‹¤. ìˆ˜ì • ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ì—…ë°ì´íŠ¸í•˜ì„¸ìš”.';
                            console.warn(`ì†ì„±ì— ê¸°ì¡´ ë°ì´í„° ì¡´ì¬: ${item.attribute}`);
                            displayExtractedAttributes();
                            continue;
                        }
                        
                        console.log(`ì†ì„± ì €ì¥ ì‹œë„: ${combinedAttributeText}`, { 
                            originalAttribute: item.attribute,
                            finalNovelTitle, 
                            novelTitleBits,
                            finalChapter,
                            chapterBits,
                            combinedAttributeBits
                        });
                        const url = getServerUrl('/api/attributes/data');
                        const res = await fetch(url, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                attributeBitMax: combinedAttributeBits.max,
                                attributeBitMin: combinedAttributeBits.min,
                                attributeText: combinedAttributeText,
                                text: item.data,
                                dataBitMax: item.dataBitMax,
                                dataBitMin: item.dataBitMin,
                                novelTitle: finalNovelTitle,
                                novelTitleBitMax: novelTitleBits.max,
                                novelTitleBitMin: novelTitleBits.min,
                                chapter: finalChapter,
                                chapterBitMax: chapterBits.max,
                                chapterBitMin: chapterBits.min
                            })
                        });

                        console.log(`ì†ì„± ì €ì¥ API ì‘ë‹µ: ${item.attribute}`, { status: res.status });

                        if (!res.ok) {
                            throw new Error(`HTTP ${res.status}`);
                        }

                        const data = await res.json();
                        if (data.ok) {
                            if (data.duplicate) {
                                // APIì—ì„œ ì¤‘ë³µ í™•ì¸ëœ ê²½ìš°ë„ ì €ì¥í•˜ì§€ ì•ŠìŒ
                                duplicateCount++;
                                item.saveStatus = 'duplicate';
                                item.saveMessage = 'ì¤‘ë³µëœ ë°ì´í„°ì…ë‹ˆë‹¤. ìˆ˜ì • ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ì—…ë°ì´íŠ¸í•˜ì„¸ìš”.';
                                console.warn(`ì†ì„± ì¤‘ë³µ: ${item.attribute}`);
                            } else {
                                successCount++;
                                item.saveStatus = 'success';
                                item.saveMessage = 'ì €ì¥ ì™„ë£Œ';
                                console.log(`ì†ì„± ì €ì¥ ì™„ë£Œ: ${item.attribute}`);
                            }
                        } else {
                            throw new Error(data.error || 'ì €ì¥ ì‹¤íŒ¨');
                        }
                    } catch (e) {
                        console.error(`ì†ì„± "${item.attribute}" ì €ì¥ ì˜¤ë¥˜:`, e);
                        errorCount++;
                        item.saveStatus = 'error';
                        item.saveMessage = e.message || 'ì €ì¥ ì‹¤íŒ¨';
                    }
                    
                    // ê° í•­ëª© ì €ì¥ í›„ ì¦‰ì‹œ í™”ë©´ ì—…ë°ì´íŠ¸
                    displayExtractedAttributes();
                }

                // ì „ì²´ ì €ì¥ ì™„ë£Œ ìƒíƒœ ì—…ë°ì´íŠ¸
                console.log('ì†ì„± ì €ì¥ ì™„ë£Œ', { success: successCount, duplicate: duplicateCount, error: errorCount });
                $gptStatus.textContent = `âœ“ ì €ì¥ ì™„ë£Œ: ì„±ê³µ ${successCount}ê°œ, ì¤‘ë³µ ${duplicateCount}ê°œ, ì‹¤íŒ¨ ${errorCount}ê°œ`;
                $gptStatus.style.color = '#28a745';
                
                // ì†ì„± ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                console.log('ì†ì„± ëª©ë¡ ìƒˆë¡œê³ ì¹¨ ì˜ˆì•½');
                setTimeout(() => {
                    loadAttributes();
                }, 500);
            } catch (e) {
                console.error('ì €ì¥ ì˜¤ë¥˜:', e);
                $gptStatus.textContent = `âœ— ì €ì¥ ì‹¤íŒ¨: ${e.message}`;
                $gptStatus.style.color = '#dc3545';
            }
        }

        // GPT ë¶„ì„ ë²„íŠ¼ ì´ë²¤íŠ¸
        $analyzeBtn1.addEventListener('click', () => {
            const prompt = $gptPrompt1.value.trim();
            analyzeWithGPT(prompt);
        });
        
        $analyzeBtn2.addEventListener('click', () => {
            analyzeWithGPT2();
        });

        // í”„ë¡¬í”„íŠ¸ 1ìš© ë¡œê·¸ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        function updatePromptLog1(systemMessage, userPrompt) {
            if (!$gptPromptLog) return;
            
            // ë°ì´í„° í•„ë“œ ì œì™¸ ì²˜ë¦¬
            let cleanedPrompt = userPrompt;
            
            // [ë¶„ì„í•  í…ìŠ¤íŠ¸] ë˜ëŠ” í…ìŠ¤íŠ¸ ë°ì´í„° ë¶€ë¶„ì„ ì œì™¸
            cleanedPrompt = cleanedPrompt.replace(/\[ë¶„ì„í•  í…ìŠ¤íŠ¸\][\s\S]*?(?=\n\n|\n===|$)/g, '[ë¶„ì„í•  í…ìŠ¤íŠ¸]\n(ë°ì´í„° ì œì™¸)');
            cleanedPrompt = cleanedPrompt.replace(/\[í…ìŠ¤íŠ¸\][\s\S]*?(?=\n\n|\n===|$)/g, '[í…ìŠ¤íŠ¸]\n(ë°ì´í„° ì œì™¸)');
            
            // í”„ë¡¬í”„íŠ¸ 1ìš© ë¡œê·¸ í˜•ì‹
            const promptLogText = `=== í”„ë¡¬í”„íŠ¸ 1 ===\n\n=== ì‹œìŠ¤í…œ ë©”ì‹œì§€ ===\n${systemMessage}\n\n=== ì‚¬ìš©ì í”„ë¡¬í”„íŠ¸ ===\n${cleanedPrompt}`;
            
            $gptPromptLog.value = promptLogText;
            console.log('í”„ë¡¬í”„íŠ¸ 1 ë¡œê·¸ ì—…ë°ì´íŠ¸ë¨');
        }

        // í”„ë¡¬í”„íŠ¸ 2ìš© ë¡œê·¸ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        function updatePromptLog2(systemMessage, userPrompt) {
            if (!$gptPromptLog) return;
            
            // ë°ì´í„° í•„ë“œ ì œì™¸ ì²˜ë¦¬
            let cleanedPrompt = userPrompt;
            
            // [ì°¸ê³  í…ìŠ¤íŠ¸] ë¶€ë¶„ì„ ì œì™¸í•˜ê³  "(ë°ì´í„° ì œì™¸)"ë¡œ êµì²´
            cleanedPrompt = cleanedPrompt.replace(/\[ì°¸ê³  í…ìŠ¤íŠ¸\][\s\S]*?(?=\n\nìœ„ ì •ë³´|\nìœ„ ì •ë³´|$)/g, '[ì°¸ê³  í…ìŠ¤íŠ¸]\n(ë°ì´í„° ì œì™¸)');
            
            // ì‹œìŠ¤í…œ ë©”ì‹œì§€ê°€ ìˆìœ¼ë©´ í¬í•¨, ì—†ìœ¼ë©´ ì‚¬ìš©ì í”„ë¡¬í”„íŠ¸ë§Œ í‘œì‹œ
            const promptLogText = systemMessage && systemMessage.trim() 
                ? `${systemMessage}

${cleanedPrompt}`
                : cleanedPrompt;
            
            $gptPromptLog.value = promptLogText;
            console.log('í”„ë¡¬í”„íŠ¸ 2 ë¡œê·¸ ì—…ë°ì´íŠ¸ë¨');
        }

        // ì†ì„± ì…ë ¥ë€ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        function updateSelectedAttributeInput(attribute) {
            if (!$selectedAttributeInput) {
                console.warn('ì†ì„± ì…ë ¥ë€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }
            
            $selectedAttributeInput.value = attribute;
            console.log('ì†ì„± ì…ë ¥ë€ì— ìë™ ì…ë ¥:', attribute);
        }

        // ì†ì„± ì…ë ¥ë€ ê°’ ê°€ì ¸ì˜¤ê¸° í•¨ìˆ˜
        function getSelectedAttributeInput() {
            if (!$selectedAttributeInput) {
                console.warn('ì†ì„± ì…ë ¥ë€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return '';
            }
            
            return $selectedAttributeInput.value.trim();
        }

        // ì†ì„± ì…ë ¥ë€ ì´ˆê¸°í™” í•¨ìˆ˜
        function clearSelectedAttributeInput() {
            if (!$selectedAttributeInput) {
                console.warn('ì†ì„± ì…ë ¥ë€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }
            
            $selectedAttributeInput.value = '';
            console.log('ì†ì„± ì…ë ¥ë€ ì´ˆê¸°í™”ë¨');
        }

        // ì±•í„° ë¶„ì„ ë‚´ìš© ì €ì¥ ë° ê²Œì‹œ ì²˜ë¦¬
        function saveChapterAnalysis(text, publish = true) {
            try {
                if (currentChapterIdx === null || currentChapterIdx === undefined || currentChapterIdx < 0 || currentChapterIdx >= chapters.length) {
                    console.warn('ì±•í„° ë¶„ì„ ì €ì¥ ì‹¤íŒ¨: ì„ íƒëœ ì±•í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
                    return;
                }
                const chapter = chapters[currentChapterIdx];
                chapter.analysisText = String(text || '').trim();
                if (publish) {
                    chapter.published = true;
                    chapter.publishedAt = new Date().toISOString();
                }
                saveChapters();
                renderChapters();
                addLog('info', `ì±•í„° ë¶„ì„ ë‚´ìš© ${publish ? 'ê²Œì‹œ' : 'ì €ì¥'} ì™„ë£Œ: ${chapter.number || ''} ${chapter.title || ''}`);
                if ($gptStatus) {
                    $gptStatus.textContent = publish ? 'âœ“ ì±•í„° ë¶„ì„ ì €ì¥ ë° ê²Œì‹œ ì™„ë£Œ' : 'âœ“ ì±•í„° ë¶„ì„ ì €ì¥ ì™„ë£Œ';
                    $gptStatus.style.color = '#28a745';
                }
            } catch (e) {
                console.error('ì±•í„° ë¶„ì„ ì €ì¥ ì˜¤ë¥˜:', e);
            }
        }

        // GPT ë¶„ì„ í•¨ìˆ˜ 2: ì†ì„± ê²°ì • í›„ í”„ë¡¬í”„íŠ¸ 2 ì ìš©
        async function analyzeWithGPT2() {
            const text = $gptInput.value.trim();
            if (!text) {
                console.warn('GPT ë¶„ì„: ë¶„ì„í•  í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.');
                $gptStatus.textContent = 'âœ— ë¶„ì„í•  í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”.';
                $gptStatus.style.color = '#dc3545';
                return;
            }

            const prompt2 = $gptPrompt2.value.trim();
            if (!prompt2) {
                console.warn('GPT ë¶„ì„ 2: í”„ë¡¬í”„íŠ¸ ì…ë ¥ 2ê°€ ì—†ìŠµë‹ˆë‹¤.');
                $gptStatus.textContent = 'âœ— í”„ë¡¬í”„íŠ¸ ì…ë ¥ 2ë¥¼ ì…ë ¥í•˜ì„¸ìš”.';
                $gptStatus.style.color = '#dc3545';
                return;
            }

            console.log('GPT ë¶„ì„ 2 ì‹œì‘', { prompt2, textLength: text.length });

            try {
                // ë‘ ë²„íŠ¼ ëª¨ë‘ ë¹„í™œì„±í™”
                $analyzeBtn1.disabled = true;
                $analyzeBtn2.disabled = true;
                $gptStatus.textContent = 'GPT AI ë¶„ì„ ì¤‘... (ì†ì„± ê²°ì • ì¤‘)';
                $gptStatus.style.color = '#007bff';
                $gptResponse.textContent = 'ë¶„ì„ ì¤‘...';

                // ì†Œì„¤ ì œëª©ê³¼ ì±•í„° ì •ë³´ ê°€ì ¸ì˜¤ê¸°
                const novelTitle = $novelTitle.value.trim();
                const currentChapter = currentChapterIdx !== null && chapters[currentChapterIdx] ? chapters[currentChapterIdx] : null;
                
                if (!novelTitle) {
                    console.warn('ì†Œì„¤ ì œëª©ì´ ì…ë ¥ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                    $gptStatus.textContent = 'âœ— ì†Œì„¤ ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš”.';
                    $gptStatus.style.color = '#dc3545';
                    $analyzeBtn1.disabled = false;
                    $analyzeBtn2.disabled = false;
                    return;
                }
                
                if (!currentChapter) {
                    console.warn('ì±•í„°ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                    $gptStatus.textContent = 'âœ— ì±•í„°ë¥¼ ì„ íƒí•˜ì„¸ìš”.';
                    $gptStatus.style.color = '#dc3545';
                    $analyzeBtn1.disabled = false;
                    $analyzeBtn2.disabled = false;
                    return;
                }
                
                // ì €ì¥ëœ ì†ì„± ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
                console.log('ì €ì¥ëœ ì†ì„± ëª©ë¡ ì¡°íšŒ ì‹œì‘', { novelTitle, currentChapter });
                const allAttrUrl = getServerUrl('/api/attributes/all');
                const allAttrRes = await fetch(allAttrUrl);
                let savedAttributes = [];
                
                if (allAttrRes.ok) {
                    const allAttrData = await allAttrRes.json();
                    if (allAttrData.ok && allAttrData.attributes) {
                        // ì •í™•í•œ ì±•í„° ë§¤ì¹­ì„ ìœ„í•œ ë¬¸ìì—´ ìƒì„± (ì €ì¥ ì‹œ í˜•ì‹ê³¼ ë™ì¼í•˜ê²Œ)
                        const chapterNumber = (currentChapter.number || '').trim();
                        const chapterTitle = (currentChapter.title || '').trim();
                        const chapterDisplay = `${chapterNumber}${chapterTitle ? `: ${chapterTitle}` : ''}`;
                        const expectedPrefix = `${novelTitle} â†’ ${chapterDisplay} â†’ `;
                        
                        console.log('ì±•í„° í•„í„°ë§ ì¡°ê±´:', { 
                            expectedPrefix, 
                            chapterNumber, 
                            chapterTitle,
                            chapterDisplay,
                            totalAttributes: allAttrData.attributes.length 
                        });
                        
                        // ë””ë²„ê¹…: ì²« ëª‡ ê°œ ì†ì„±ì˜ í˜•ì‹ í™•ì¸
                        const sampleAttrs = allAttrData.attributes.slice(0, 5);
                        console.log('ìƒ˜í”Œ ì†ì„± í˜•ì‹:', sampleAttrs.map(attr => attr.text));
                        
                        savedAttributes = allAttrData.attributes
                            .filter(attr => {
                                const attrText = (attr.text || '').trim();
                                
                                // ì •í™•íˆ 100% ì¼ì¹˜í•˜ëŠ” ì†ì„±ë§Œ í•„í„°ë§
                                // ì €ì¥ í˜•ì‹: "ë‹¤í¬ íŒíƒ€ì§€ â†’ ì±•í„° 2: ì œ1ì¥ â†’ ë“±ì¥ì¸ë¬¼"
                                // expectedPrefix: "ë‹¤í¬ íŒíƒ€ì§€ â†’ ì±•í„° 2: ì œ1ì¥ â†’ "
                                
                                // 1ë‹¨ê³„: ì •í™•í•œ prefix ë§¤ì¹­
                                const startsWithPrefix = attrText.startsWith(expectedPrefix);
                                
                                if (!startsWithPrefix) {
                                    return false;
                                }
                                
                                // 2ë‹¨ê³„: ì¶”ê°€ ê²€ì¦ - ì±•í„° ë¶€ë¶„ì´ ì •í™•íˆ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸
                                const attrParts = attrText.split(' â†’ ');
                                if (attrParts.length < 3) {
                                    // í˜•ì‹ì´ ë§ì§€ ì•Šìœ¼ë©´ ì œì™¸
                                    return false;
                                }
                                
                                const attrNovelTitle = attrParts[0].trim();
                                const attrChapterPart = attrParts[1].trim(); // "ì±•í„° 2: ì œ1ì¥"
                                
                                // ì†Œì„¤ ì œëª©ê³¼ ì±•í„°ê°€ ì •í™•íˆ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸
                                const novelMatches = attrNovelTitle === novelTitle.trim();
                                const chapterMatches = attrChapterPart === chapterDisplay;
                                
                                if (novelMatches && chapterMatches) {
                                    console.log('100% ì¼ì¹˜í•˜ëŠ” ì†ì„± ë°œê²¬:', { 
                                        attrText, 
                                        expectedPrefix,
                                        attrNovelTitle,
                                        attrChapterPart,
                                        expectedNovel: novelTitle.trim(),
                                        expectedChapter: chapterDisplay
                                    });
                                    return true;
                                }
                                
                                // ì¼ì¹˜í•˜ì§€ ì•Šìœ¼ë©´ ë¡œê·¸ ì¶œë ¥
                                console.log('ì†ì„± ë¶ˆì¼ì¹˜:', { 
                                    attrText, 
                                    attrNovelTitle, 
                                    attrChapterPart,
                                    expectedNovel: novelTitle.trim(),
                                    expectedChapter: chapterDisplay,
                                    novelMatches,
                                    chapterMatches
                                });
                                
                                return false;
                            })
                            .map(attr => {
                                // ì†ì„±ëª…ë§Œ ì¶”ì¶œ (ì˜ˆ: "ë‹¤í¬ íŒíƒ€ì§€ â†’ ì±•í„° 1: ê°œìš” â†’ ë“±ì¥ì¸ë¬¼" â†’ "ë“±ì¥ì¸ë¬¼")
                                const parts = attr.text.split(' â†’ ');
                                return parts.length >= 3 ? parts[parts.length - 1] : attr.text;
                            });
                        console.log('ì €ì¥ëœ ì†ì„± ëª©ë¡ í•„í„°ë§ ì™„ë£Œ', { 
                            count: savedAttributes.length,
                            filteredAttributes: savedAttributes 
                        });
                    }
                }

                // ì²« ë²ˆì§¸ GPT í˜¸ì¶œ: ì†ì„± ê²°ì • (ì €ì¥ëœ ì†ì„± ëª©ë¡ ê¸°ë°˜)
                console.log('1ë‹¨ê³„: ì†ì„± ê²°ì • ì‹œì‘ (ì €ì¥ëœ ì†ì„± ëª©ë¡ ê¸°ë°˜)');
                const chapterDisplay = `${currentChapter.number}${currentChapter.title ? `: ${currentChapter.title}` : ''}`;
                const attributeSystemMessage = `ë‹¹ì‹ ì€ ì†Œì„¤ í…ìŠ¤íŠ¸ë¥¼ ë¶„ì„í•˜ì—¬ ì–´ë–¤ ì†ì„±(ì†Œì„¤ êµ¬ì„± ìš”ì†Œ)ì„ ë¶„ì„í• ì§€ ê²°ì •í•˜ëŠ” ì „ë¬¸ê°€ì…ë‹ˆë‹¤.

ì‚¬ìš©ìì˜ ìš”ì²­: "${prompt2}"

í˜„ì¬ ì†Œì„¤: "${novelTitle}"
í˜„ì¬ ì±•í„°: "${chapterDisplay}"

ì €ì¥ëœ ì†ì„± ëª©ë¡:
${savedAttributes.length > 0 ? savedAttributes.map((attr, idx) => `- ${attr}`).join('\n') : '- ë“±ì¥ì¸ë¬¼\n- ë°°ê²½ ì„¤ì •\n- ì£¼ìš” ì‚¬ê±´\n- ê°ì •/ë¶„ìœ„ê¸°\n- í…Œë§ˆ/ì£¼ì œ\n- ìŠ¤íƒ€ì¼/í†¤'}

**ì¤‘ìš”**: 
- ì €ì¥ëœ ì†ì„± ëª©ë¡ ì¤‘ì—ì„œ ì‚¬ìš©ìì˜ ìš”ì²­ "${prompt2}"ì— ê°€ì¥ ì í•©í•œ ì†ì„± ì´ë¦„ í•˜ë‚˜ë¥¼ ì •í™•íˆ ì„ íƒí•˜ì„¸ìš”.
- ì €ì¥ëœ ì†ì„± ëª©ë¡ì— ì—†ëŠ” ê²½ìš° ê¸°ë³¸ ì†ì„± ì¤‘ì—ì„œ ì„ íƒí•˜ì„¸ìš”.
- ë‹¤ë¥¸ ì„¤ëª… ì—†ì´ ì†ì„± ì´ë¦„ë§Œ ì •í™•íˆ ë°˜í™˜í•˜ì„¸ìš”.
- ì˜ˆ: ì‚¬ìš©ìê°€ "ë“±ì¥ì¸ë¬¼ì„" ë˜ëŠ” "ë“±ì¥ì¸ë¬¼ì— ëŒ€í•´" ìš”ì²­í•˜ë©´ â†’ "ë“±ì¥ì¸ë¬¼"
- ì˜ˆ: ì‚¬ìš©ìê°€ "ë°°ê²½" ë˜ëŠ” "ì„¤ì •"ì„ ìš”ì²­í•˜ë©´ â†’ "ë°°ê²½ ì„¤ì •"
- ì˜ˆ: ì‚¬ìš©ìê°€ "ê°œìš”ë¥¼ ì¨ì¤˜"ë¼ê³  í–ˆì§€ë§Œ ì†ì„±ì„ ëª…ì‹œí•˜ì§€ ì•Šì•˜ë‹¤ë©´, í…ìŠ¤íŠ¸ë¥¼ ë³´ê³  ê°€ì¥ ì í•©í•œ ì†ì„±ì„ ì„ íƒí•˜ì„¸ìš”.`;

                const attributePrompt = `ë‹¤ìŒ ì†Œì„¤ í…ìŠ¤íŠ¸ë¥¼ ë¶„ì„í•˜ì—¬, ì‚¬ìš©ì ìš”ì²­ "${prompt2}"ì— í•´ë‹¹í•˜ëŠ” ì†ì„± í•˜ë‚˜ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.

ì €ì¥ëœ ì†ì„± ëª©ë¡:
${savedAttributes.length > 0 ? savedAttributes.map((attr, idx) => `- ${attr}`).join('\n') : '- ë“±ì¥ì¸ë¬¼\n- ë°°ê²½ ì„¤ì •\n- ì£¼ìš” ì‚¬ê±´\n- ê°ì •/ë¶„ìœ„ê¸°\n- í…Œë§ˆ/ì£¼ì œ\n- ìŠ¤íƒ€ì¼/í†¤'}

[í…ìŠ¤íŠ¸]
${text}

ìœ„ ìš”ì²­ê³¼ ì €ì¥ëœ ì†ì„± ëª©ë¡ì„ ê³ ë ¤í•˜ì—¬ ê°€ì¥ ì í•©í•œ ì†ì„± ì´ë¦„ í•˜ë‚˜ë§Œ ì •í™•íˆ ë°˜í™˜í•˜ì„¸ìš”.`;

                // í”„ë¡¬í”„íŠ¸ ë¡œê·¸ ì´ˆê¸°í™” (í”„ë¡¬í”„íŠ¸ 2 ì‹œì‘ ì „)
                if ($gptPromptLog) {
                    $gptPromptLog.value = '';
                }

                // ëª¨ë¸ ì„ íƒ (í•¨ìˆ˜ ì‹œì‘ ë¶€ë¶„ì—ì„œ í•œ ë²ˆë§Œ ì„ ì–¸)
                const selectedModel = $gptModelSelect ? $gptModelSelect.value : 'gpt-4o-mini';
                const attributeUrl = getServerUrl('/api/gpt/chat');
                const attributeRes = await fetch(attributeUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: attributePrompt,
                        systemMessage: attributeSystemMessage,
                        // ì†ì„± ê²°ì •ì€ í•­ìƒ gpt-4o-mini ì‚¬ìš©
                        model: 'gpt-4o-mini',
                        temperature: 0.3,
                        maxTokens: 100
                    })
                });

                if (!attributeRes.ok) {
                    // ì„œë²„ ì—ëŸ¬ ë©”ì‹œì§€ ì½ê¸° (ë³¸ë¬¸ì€ í•œ ë²ˆë§Œ ì½ëŠ”ë‹¤)
                    let errorMessage = `HTTP ${attributeRes.status}`;
                    const raw = await attributeRes.text().catch(() => '');
                    if (raw) {
                        try {
                            const errorData = JSON.parse(raw);
                            errorMessage = errorData.error || errorData.message || errorMessage;
                            console.error('ì†ì„± ê²°ì • API ì˜¤ë¥˜ ìƒì„¸', { status: attributeRes.status, error: errorMessage, errorData });
                        } catch {
                            errorMessage = raw || errorMessage;
                            console.error('ì†ì„± ê²°ì • API ì˜¤ë¥˜ (í…ìŠ¤íŠ¸)', { status: attributeRes.status, error: errorMessage });
                        }
                        if (errorMessage.includes('not supported') || errorMessage.includes('not in v1/chat/completions')) {
                            errorMessage = `ì„ íƒí•œ ëª¨ë¸ "${selectedModel}"ì€(ëŠ”) í˜„ì¬ APIì—ì„œ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë‹¤ë¥¸ ëª¨ë¸ì„ ì„ íƒí•´ì£¼ì„¸ìš”. (ê¶Œì¥: gpt-4o-mini, gpt-4o)`;
                        }
                    }
                    throw new Error(errorMessage);
                }

                const attributeData = await attributeRes.json();
                if (!attributeData.ok) {
                    throw new Error(attributeData.error || 'ì†ì„± ê²°ì • ì‹¤íŒ¨');
                }

                // ì†ì„± ì´ë¦„ ì¶”ì¶œ
                let selectedAttribute = attributeData.response.trim();
                // ì†ì„± ì´ë¦„ë§Œ ì¶”ì¶œ (ë¶ˆí•„ìš”í•œ ì„¤ëª… ì œê±°)
                const lowerResponse = selectedAttribute.toLowerCase();
                
                if (lowerResponse.includes('ë“±ì¥ì¸ë¬¼') || lowerResponse.includes('ì¸ë¬¼')) {
                    selectedAttribute = 'ë“±ì¥ì¸ë¬¼';
                } else if (lowerResponse.includes('ë°°ê²½') && (lowerResponse.includes('ì„¤ì •') || lowerResponse.includes('ì¥ì†Œ') || lowerResponse.includes('ì„¸ê³„'))) {
                    selectedAttribute = 'ë°°ê²½ ì„¤ì •';
                } else if ((lowerResponse.includes('ì£¼ìš”') && lowerResponse.includes('ì‚¬ê±´')) || lowerResponse.includes('ì‚¬ê±´') || lowerResponse.includes('í”Œë¡¯')) {
                    selectedAttribute = 'ì£¼ìš” ì‚¬ê±´';
                } else if ((lowerResponse.includes('ê°ì •') || lowerResponse.includes('ë¶„ìœ„ê¸°')) && !lowerResponse.includes('í…Œë§ˆ')) {
                    selectedAttribute = 'ê°ì •/ë¶„ìœ„ê¸°';
                } else if (lowerResponse.includes('í…Œë§ˆ') || lowerResponse.includes('ì£¼ì œ') || lowerResponse.includes('ë©”ì‹œì§€')) {
                    selectedAttribute = 'í…Œë§ˆ/ì£¼ì œ';
                } else if (lowerResponse.includes('ìŠ¤íƒ€ì¼') || lowerResponse.includes('í†¤') || lowerResponse.includes('ë¬¸ì²´')) {
                    selectedAttribute = 'ìŠ¤íƒ€ì¼/í†¤';
                } else {
                    // ê¸°ë³¸ê°’: í”„ë¡¬í”„íŠ¸ 2ì˜ ê°’ì„ ì†ì„±ìœ¼ë¡œ ì‚¬ìš©
                    console.warn('ì†ì„±ì„ ìë™ìœ¼ë¡œ ê²°ì •í•  ìˆ˜ ì—†ì–´ í”„ë¡¬í”„íŠ¸ 2 ê°’ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.', { response: selectedAttribute, prompt2 });
                    selectedAttribute = prompt2;
                }

                console.log('ì„ íƒëœ ì†ì„±', { selectedAttribute, originalResponse: attributeData.response });

                // ì„ íƒëœ ì†ì„±ì„ ì…ë ¥ë€ì— ìë™ ì…ë ¥ (ì†Œì„¤ ì œëª© â†’ ì±•í„° í˜•ì‹)
                const attributeDisplayText = `${novelTitle} â†’ ${chapterDisplay}`;
                updateSelectedAttributeInput(attributeDisplayText);

                // ë‘ ë²ˆì§¸ GPT í˜¸ì¶œ: ì†Œì„¤ ì‘ê°€ê°€ ë˜ì–´ì„œ í”„ë¡¬í”„íŠ¸ ìš”êµ¬ëŒ€ë¡œ ì‘ì„±
                console.log('2ë‹¨ê³„: ì†Œì„¤ ì‘ê°€ ì—­í• ë¡œ ì‘ì„± ì‹œì‘', { attribute: selectedAttribute });
                
                // ì†ì„± ì…ë ¥ë€ì—ì„œ ê°’ ê°€ì ¸ì˜¤ê¸° (í”„ë¡¬í”„íŠ¸ì™€ ì €ì¥ ì‹œ ëª¨ë‘ ì‚¬ìš©)
                const attributeFromInput = getSelectedAttributeInput();
                const displayAttribute = attributeFromInput && attributeFromInput.trim() ? attributeFromInput.trim() : selectedAttribute;
                $gptStatus.textContent = `GPT AI ì‘ê°€ ì‘ë™ ì¤‘... (${displayAttribute} ì‘ì„± ì¤‘)`;
                
                // ì €ì¥ëœ ì†ì„± ì •ë³´ ê°€ì ¸ì˜¤ê¸° (ì°¸ê³ ìš©)
                const combinedAttributeText = `${novelTitle} â†’ ${chapterDisplay} â†’ ${selectedAttribute}`;
                const savedAttributeInfo = savedAttributes.length > 0 
                    ? `\n\nì €ì¥ëœ ì†ì„± ì°¸ê³ :\n${savedAttributes.map(attr => `- ${attr}`).join('\n')}`
                    : '';
                
                const analysisPrompt = `ì†Œì„¤ ì‘ê°€ë¡œì„œ "${attributeFromInput}" ë‹¤ìŒ ì´ì•¼ê¸°ë¥¼ ì‘ì„±í•´ì£¼ì„¸ìš”.

í˜„ì¬ ì†Œì„¤: "${novelTitle}"
í˜„ì¬ ì±•í„°: "${chapterDisplay}"
ì‚¬ìš©ì ìš”ì²­: "${prompt2}"

[ì´ì „ ì´ì•¼ê¸°]
${text}
${savedAttributeInfo}`;

                // í”„ë¡¬í”„íŠ¸ 2ìš© í”„ë¡¬í”„íŠ¸ ë¡œê·¸ ì €ì¥ (ë°ì´í„° ì œì™¸, ì‹œìŠ¤í…œ ë©”ì‹œì§€ ì—†ìŒ)
                updatePromptLog2('', analysisPrompt);

                // ì´ë¯¸ ì„ ì–¸ëœ selectedModel ì¬ì‚¬ìš©
                const useResponsesApi = selectedModel && (selectedModel.startsWith('gpt-5') || selectedModel === 'gpt-4.1-mini');
                const analysisUrl = getServerUrl(useResponsesApi ? '/api/gpt/responses' : '/api/gpt/chat');
                const analysisRes = await fetch(analysisUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(useResponsesApi ? {
                        input: analysisPrompt,
                        systemMessage: '',
                        model: selectedModel,
                        // gpt-5 ê³„ì—´ì€ temperature ê¸°ë³¸ê°’ ì‚¬ìš©, ì„œë²„ì—ì„œ ìë™ ì²˜ë¦¬
                        maxTokens: 1500,
                        truncate: true
                    } : {
                        prompt: analysisPrompt,
                        systemMessage: '',
                        model: selectedModel,
                        temperature: 0.3,
                        maxTokens: 1500
                    })
                });

                if (!analysisRes.ok) {
                    // ì„œë²„ ì—ëŸ¬ ë©”ì‹œì§€ ì½ê¸° (ë³¸ë¬¸ì€ í•œ ë²ˆë§Œ ì½ëŠ”ë‹¤)
                    let errorMessage = `HTTP ${analysisRes.status}`;
                    const raw = await analysisRes.text().catch(() => '');
                    if (raw) {
                        try {
                            const errorData = JSON.parse(raw);
                            errorMessage = errorData.error || errorData.message || errorMessage;
                            console.error('ì†ì„± ë¶„ì„ API ì˜¤ë¥˜ ìƒì„¸', { status: analysisRes.status, error: errorMessage, errorData });
                        } catch {
                            errorMessage = raw || errorMessage;
                            console.error('ì†ì„± ë¶„ì„ API ì˜¤ë¥˜ (í…ìŠ¤íŠ¸)', { status: analysisRes.status, error: errorMessage });
                        }
                        if (errorMessage.includes('not supported') || errorMessage.includes('not in v1/chat/completions')) {
                            errorMessage = `ì„ íƒí•œ ëª¨ë¸ "${selectedModel}"ì€(ëŠ”) í˜„ì¬ APIì—ì„œ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë‹¤ë¥¸ ëª¨ë¸ì„ ì„ íƒí•´ì£¼ì„¸ìš”. (ê¶Œì¥: gpt-4o-mini, gpt-4o)`;
                        }
                    }
                    throw new Error(errorMessage);
                }

                const analysisData = await analysisRes.json();
                if (!analysisData.ok) {
                    throw new Error(analysisData.error || 'ì†ì„± ë¶„ì„ ì‹¤íŒ¨');
                }

                console.log('ì†ì„± ë¶„ì„ ì™„ë£Œ');

                // ì‘ë‹µ íŒŒì‹±
                let parsed = [];
                try {
                    const responseText = analysisData.response.trim();
                    
                    // í”„ë¡¬í”„íŠ¸ 2ëŠ” ì´ì•¼ê¸° ì´ì–´ì“°ê¸°ì´ë¯€ë¡œ, íŠ¹ì • í˜•ì‹ì´ ì—†ìœ¼ë©´ ì „ì²´ ì‘ë‹µì„ ë°ì´í„°ë¡œ ì‚¬ìš©
                    // "ì†ì„±:" ë˜ëŠ” "ë°ì´í„°:" íŒ¨í„´ì´ ìˆëŠ”ì§€ í™•ì¸
                    const hasStructuredFormat = /ì†ì„±\s*:|ë°ì´í„°\s*:/i.test(responseText);
                    
                    if (hasStructuredFormat) {
                        // êµ¬ì¡°í™”ëœ í˜•ì‹ (ì†ì„±: ... ë°ì´í„°: ...)
                        const attrMatch = responseText.match(/ì†ì„±\s*:\s*(.+?)(?:\n|$)/i);
                    const attribute = attrMatch ? attrMatch[1].trim() : selectedAttribute;
                    
                        const dataMatch = responseText.match(/ë°ì´í„°\s*:\s*(.+?)(?:\n\nì†ì„±\s*BIT:|\nì†ì„±\s*BIT:|$)/is);
                    const dataText = dataMatch ? dataMatch[1].trim() : responseText;
                    
                    if (attribute && dataText) {
                        parsed.push({
                            attribute: attribute,
                            data: dataText,
                            reasoning: ''
                        });
                        }
                    } else {
                        // êµ¬ì¡°í™”ëœ í˜•ì‹ì´ ì—†ìœ¼ë©´ ì „ì²´ ì‘ë‹µì„ ì´ì•¼ê¸° ë°ì´í„°ë¡œ ì‚¬ìš© (í”„ë¡¬í”„íŠ¸ 2ì˜ ê²½ìš°)
                        console.log('êµ¬ì¡°í™”ëœ í˜•ì‹ì´ ì—†ìŒ. ì „ì²´ ì‘ë‹µì„ ë°ì´í„°ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤.');
                        const finalAttribute = attributeFromInput && attributeFromInput.trim() 
                            ? attributeFromInput.trim() 
                            : selectedAttribute;
                        
                        if (finalAttribute && responseText) {
                            parsed.push({
                                attribute: finalAttribute,
                                data: responseText,
                                reasoning: ''
                            });
                        }
                    }
                } catch (e) {
                    console.error('íŒŒì‹± ì˜¤ë¥˜:', e);
                    // íŒŒì‹± ì‹¤íŒ¨ ì‹œ ì „ì²´ ì‘ë‹µì„ ë°ì´í„°ë¡œ ì‚¬ìš©
                    const finalAttribute = attributeFromInput && attributeFromInput.trim() 
                        ? attributeFromInput.trim() 
                        : selectedAttribute;
                    
                    if (finalAttribute && analysisData.response) {
                    parsed.push({
                            attribute: finalAttribute,
                        data: analysisData.response,
                        reasoning: ''
                    });
                    }
                }

                if (parsed.length === 0) {
                    console.error('íŒŒì‹± ê²°ê³¼ê°€ ë¹„ì–´ìˆìŒ', { responseLength: analysisData.response?.length || 0, responsePreview: analysisData.response?.substring(0, 100) });
                    throw new Error('ë¶„ì„ ê²°ê³¼ë¥¼ íŒŒì‹±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì‘ë‹µ: ' + (analysisData.response?.substring(0, 200) || 'ì—†ìŒ'));
                }

                // ì¶”ì¶œëœ ì†ì„± ì²˜ë¦¬ (attributeFromInputì€ ìœ„ì—ì„œ ì´ë¯¸ ì„ ì–¸ë¨)
                extractedAttributesList = parsed.map(item => {
                    // í”„ë¡¬í”„íŠ¸ 2ì¼ ë•ŒëŠ” ì†ì„± ì…ë ¥ë€ì˜ ê°’ì„ ê·¸ëŒ€ë¡œ ì†ì„±ìœ¼ë¡œ ì‚¬ìš©
                    // "ë‹¤í¬ íŒíƒ€ì§€ â†’ ì±•í„° 3: ì œ2ì¥" í˜•ì‹ì˜ ê°’ì´ ìˆìœ¼ë©´ ê·¸ê²ƒì„ ì†ì„±ìœ¼ë¡œ ì‚¬ìš©
                    const attribute = (attributeFromInput && attributeFromInput.trim()) 
                        ? attributeFromInput.trim() 
                        : (item.attribute?.trim() || selectedAttribute || '');
                    let dataText = item.data?.trim() || '';
                    
                    // ë§ˆí¬ë‹¤ìš´ ë¬¸ì ì œê±°
                    dataText = removeMarkdownChars(dataText);
                    
                    if (!attribute || !dataText) {
                        return null;
                    }

                    const attrBits = calculateBitValues(attribute);
                    const dataBits = calculateBitValues(dataText);
                    
                    console.log('ì†ì„± BIT ê³„ì‚°', { 
                        attribute, 
                        attrBitMax: attrBits.max, 
                        attrBitMin: attrBits.min,
                        dataBitMax: dataBits.max,
                        dataBitMin: dataBits.min
                    });
                    
                    return {
                        attribute: attribute,
                        data: dataText,
                        reasoning: item.reasoning?.trim() || '',
                        attributeBitMax: attrBits.max,
                        attributeBitMin: attrBits.min,
                        dataBitMax: dataBits.max,
                        dataBitMin: dataBits.min
                    };
                }).filter(Boolean);

                if (extractedAttributesList.length === 0) {
                    throw new Error('ì¶”ì¶œëœ ìœ íš¨í•œ ì†ì„±ì´ ì—†ìŠµë‹ˆë‹¤.');
                }

                // ê²°ê³¼ í‘œì‹œ
                console.log('ë¶„ì„ ê²°ê³¼ í‘œì‹œ', { attributeCount: extractedAttributesList.length });
                $gptResponse.textContent = analysisData.response;
                displayExtractedAttributes();
                $gptResultCard.style.display = 'block';
                $gptStatus.textContent = `âœ“ ë¶„ì„ ì™„ë£Œ: ${extractedAttributesList.length}ê°œ ì†ì„± ì¶”ì¶œë¨. ìë™ ì €ì¥ ì¤‘...`;
                $gptStatus.style.color = '#007bff';

                // ìë™ ì €ì¥ ì‹¤í–‰
                console.log('ìë™ ì €ì¥ ì‹œì‘');
                await saveAllAttributes();
                console.log('GPT ë¶„ì„ 2 ì™„ë£Œ');

            } catch (e) {
                console.error('GPT ë¶„ì„ 2 ì˜¤ë¥˜:', e);
                $gptStatus.textContent = `âœ— ë¶„ì„ ì‹¤íŒ¨: ${e.message}`;
                $gptStatus.style.color = '#dc3545';
                $gptResponse.textContent = `ì˜¤ë¥˜: ${e.message}`;
            } finally {
                $analyzeBtn1.disabled = false;
                $analyzeBtn2.disabled = false;
            }
        }


        // ë°ì´í„° ì…ë ¥ ì‹œ BIT ê³„ì‚°
        $newDataInput.addEventListener('input', (e) => {
            const text = e.target.value.trim();
            if (text) {
                const { max, min } = calculateBitValues(text);
                $newDataMax.textContent = max !== null ? max.toFixed(15) : '-';
                $newDataMin.textContent = min !== null ? min.toFixed(15) : '-';
            } else {
                $newDataMax.textContent = '-';
                $newDataMin.textContent = '-';
            }
        });

        // ===== í•„í„°ë§ í•¨ìˆ˜ë“¤ (ë¶„ë¦¬ëœ ëª¨ë“ˆ) =====
        
        /**
         * ê²½ë¡œê°€ ì •í™•íˆ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸ (ê²½ë¡œ í•„í„°ë§ìš©)
         * @param {string} filterPath - í•„í„° ê²½ë¡œ (ì˜ˆ: "ë‹¤í¬ íŒíƒ€ì§€ â†’ ì±•í„° 3: ì œ2ì¥")
         * @param {string} targetPath - ëŒ€ìƒ ê²½ë¡œ (ì˜ˆ: "ë‹¤í¬ íŒíƒ€ì§€ â†’ ì±•í„° 3: ì œ2ì¥" ë˜ëŠ” "ë‹¤í¬ íŒíƒ€ì§€ â†’ ì±•í„° 3: ì œ2ì¥ â†’ ë°°ê²½ ì„¤ì •")
         * @returns {boolean} ì¼ì¹˜ ì—¬ë¶€
         */
        function matchPathExact(filterPath, targetPath) {
            if (!filterPath || !targetPath) return false;
            
            const filterLower = filterPath.toLowerCase().trim();
            const targetLower = targetPath.toLowerCase().trim();
            
            // ì •í™•íˆ ì¼ì¹˜
            if (filterLower === targetLower) return true;
            
            // ë‘˜ ë‹¤ ê²½ë¡œ í˜•ì‹ì¸ ê²½ìš°
            if (filterLower.includes(' â†’ ') && targetLower.includes(' â†’ ')) {
                const filterParts = filterLower.split(' â†’ ').map(p => p.trim());
                const targetParts = targetLower.split(' â†’ ').map(p => p.trim());
                
                // í•„í„° ê²½ë¡œê°€ ëŒ€ìƒ ê²½ë¡œì˜ ì‹œì‘ ë¶€ë¶„ê³¼ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸
                if (filterParts.length <= targetParts.length) {
                    for (let i = 0; i < filterParts.length; i++) {
                        if (filterParts[i] !== targetParts[i]) {
                            return false;
                        }
                    }
                    return true;
                }
            }
            
            return false;
        }
        
        /**
         * ë°ì´í„° í•­ëª©ì´ í•„í„° í‚¤ì›Œë“œì™€ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸
         * @param {Object} data - ë°ì´í„° ê°ì²´
         * @param {string} filterKeyword - í•„í„° í‚¤ì›Œë“œ (ì†Œë¬¸ì)
         * @param {string} attributeText - ì†ì„± í…ìŠ¤íŠ¸ (ì†Œë¬¸ì)
         * @returns {boolean} ì¼ì¹˜ ì—¬ë¶€
         */
        function filterDataByKeyword(data, filterKeyword, attributeText) {
            if (!filterKeyword || !filterKeyword.trim()) return true;
            
            const filterLower = filterKeyword.toLowerCase().trim();
            
            // 1. ë°ì´í„°ì˜ attribute í•„ë“œ í™•ì¸
            if (data.attribute) {
                let dataAttributeText = '';
                if (typeof data.attribute === 'object' && data.attribute !== null && data.attribute.text) {
                    dataAttributeText = (data.attribute.text || '').toLowerCase().trim();
                } else if (typeof data.attribute === 'string') {
                    dataAttributeText = (data.attribute || '').toLowerCase().trim();
                }
                
                if (dataAttributeText) {
                    // ê²½ë¡œ í•„í„°ë§: ì •í™•í•œ ê²½ë¡œ ì¼ì¹˜ë§Œ í—ˆìš©
                    if (filterLower.includes(' â†’ ')) {
                        if (matchPathExact(filterLower, dataAttributeText)) {
                            return true;
                        }
                    } else {
                        // ì¼ë°˜ í‚¤ì›Œë“œ: ë¶€ë¶„ ì¼ì¹˜ í—ˆìš©
                        if (dataAttributeText.includes(filterLower)) {
                            return true;
                        }
                    }
                }
            }
            
            // 2. ì†ì„± í…ìŠ¤íŠ¸ í™•ì¸
            if (attributeText) {
                const attrTextLower = attributeText.toLowerCase().trim();
                
                // ê²½ë¡œ í•„í„°ë§: ì •í™•í•œ ê²½ë¡œ ì¼ì¹˜ë§Œ í—ˆìš©
                if (filterLower.includes(' â†’ ')) {
                    if (matchPathExact(filterLower, attrTextLower)) {
                        return true;
                    }
                } else {
                    // ì¼ë°˜ í‚¤ì›Œë“œ: ë¶€ë¶„ ì¼ì¹˜ í—ˆìš©
                    if (attrTextLower.includes(filterLower)) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        /**
         * ë°ì´í„° ë¦¬ìŠ¤íŠ¸ë¥¼ í•„í„° í‚¤ì›Œë“œë¡œ í•„í„°ë§
         * @param {Array} dataList - ë°ì´í„° ë¦¬ìŠ¤íŠ¸
         * @param {string} filterKeyword - í•„í„° í‚¤ì›Œë“œ
         * @param {string} attributeText - ì†ì„± í…ìŠ¤íŠ¸
         * @returns {Array} í•„í„°ë§ëœ ë°ì´í„° ë¦¬ìŠ¤íŠ¸
         */
        function filterDataListByKeyword(dataList, filterKeyword, attributeText) {
            if (!dataList || !Array.isArray(dataList)) return [];
            if (!filterKeyword || !filterKeyword.trim()) return dataList;
            
            const filterLower = filterKeyword.toLowerCase().trim();
            
            // ê²½ë¡œ í•„í„°ë§: ê° ë°ì´í„° í•­ëª©ì„ ì—„ê²©í•˜ê²Œ í™•ì¸
            return dataList.filter(data => {
                // 1. ë°ì´í„°ì˜ attribute í•„ë“œ í™•ì¸ (ê°€ì¥ ìš°ì„ )
                if (data.attribute) {
                    let dataAttributeText = '';
                    if (typeof data.attribute === 'object' && data.attribute !== null && data.attribute.text) {
                        dataAttributeText = (data.attribute.text || '').toLowerCase().trim();
                    } else if (typeof data.attribute === 'string') {
                        dataAttributeText = (data.attribute || '').toLowerCase().trim();
                    }
                    
                    if (dataAttributeText) {
                        // ê²½ë¡œ í•„í„°ë§: ì •í™•í•œ ê²½ë¡œ ì¼ì¹˜ë§Œ í—ˆìš©
                        if (filterLower.includes(' â†’ ')) {
                            if (matchPathExact(filterLower, dataAttributeText)) {
                                return true;
                            }
                            // ì¼ì¹˜í•˜ì§€ ì•Šìœ¼ë©´ ì œì™¸
                            return false;
                        } else {
                            // ì¼ë°˜ í‚¤ì›Œë“œ: ë¶€ë¶„ ì¼ì¹˜ í—ˆìš©
                            if (dataAttributeText.includes(filterLower)) {
                                return true;
                            }
                        }
                    }
                }
                
                // 2. ì†ì„± í…ìŠ¤íŠ¸ í™•ì¸ (ë°ì´í„°ì˜ attributeê°€ ì—†ê±°ë‚˜ ì¼ì¹˜í•˜ì§€ ì•ŠëŠ” ê²½ìš°)
                if (attributeText) {
                    const attrTextLower = attributeText.toLowerCase().trim();
                    
                    // ê²½ë¡œ í•„í„°ë§: ì •í™•í•œ ê²½ë¡œ ì¼ì¹˜ë§Œ í—ˆìš©
                    if (filterLower.includes(' â†’ ')) {
                        if (matchPathExact(filterLower, attrTextLower)) {
                            return true;
                        }
                        // ì¼ì¹˜í•˜ì§€ ì•Šìœ¼ë©´ ì œì™¸
                        return false;
                    } else {
                        // ì¼ë°˜ í‚¤ì›Œë“œ: ë¶€ë¶„ ì¼ì¹˜ í—ˆìš©
                        if (attrTextLower.includes(filterLower)) {
                            return true;
                        }
                    }
                }
                
                // ì¼ì¹˜í•˜ì§€ ì•Šìœ¼ë©´ ì œì™¸
                return false;
            });
        }
        
        /**
         * ì†ì„±ì´ í•„í„° í‚¤ì›Œë“œì™€ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸
         * @param {Object} attr - ì†ì„± ê°ì²´
         * @param {string} filterKeyword - í•„í„° í‚¤ì›Œë“œ (ì†Œë¬¸ì)
         * @returns {boolean} ì¼ì¹˜ ì—¬ë¶€
         */
        function filterAttributeByKeyword(attr, filterKeyword) {
            if (!filterKeyword || !filterKeyword.trim()) return true;
            
            const filterLower = filterKeyword.toLowerCase().trim();
            const attributeText = (attr.text || '').toLowerCase().trim();
            
            // 1. ì •í™•í•œ ì¼ì¹˜ í™•ì¸
            if (attributeText === filterLower || attributeText === filterLower.trim()) {
                return true;
            }
            
            // 2. ê²½ë¡œ í•„í„°ë§
            if (filterLower.includes(' â†’ ')) {
                // ê²½ë¡œê°€ ì •í™•íˆ ì¼ì¹˜í•˜ëŠ” ê²½ìš°ë§Œ í—ˆìš©
                if (matchPathExact(filterLower, attributeText)) {
                    return true;
                }
                
                // ë°ì´í„°ì˜ attribute í•„ë“œ í™•ì¸ì€ ë°ì´í„° ë ˆë²¨ í•„í„°ë§ì—ì„œ ì²˜ë¦¬
                // ì†ì„± ë ˆë²¨ì—ì„œëŠ” ì†ì„± í…ìŠ¤íŠ¸ ì¼ì¹˜ë§Œ í™•ì¸
                return false;
            } else {
                // ì¼ë°˜ í‚¤ì›Œë“œ: ë¶€ë¶„ ì¼ì¹˜ í—ˆìš©
                return attributeText.includes(filterLower);
            }
        }
        
        /**
         * ì†ì„± ë¦¬ìŠ¤íŠ¸ë¥¼ í•„í„° í‚¤ì›Œë“œë¡œ í•„í„°ë§
         * @param {Array} attributes - ì†ì„± ë¦¬ìŠ¤íŠ¸
         * @param {string} filterKeyword - í•„í„° í‚¤ì›Œë“œ
         * @returns {Array} í•„í„°ë§ëœ ì†ì„± ë¦¬ìŠ¤íŠ¸
         */
        function filterAttributesByKeyword(attributes, filterKeyword) {
            if (!attributes || !Array.isArray(attributes)) return [];
            if (!filterKeyword || !filterKeyword.trim()) return attributes;
            
            return attributes.filter(attr => filterAttributeByKeyword(attr, filterKeyword));
        }
        
        // ===== í•„í„°ë§ í•¨ìˆ˜ ë =====

        // ì†ì„± ëª©ë¡ ë¡œë“œ
        async function loadAttributes() {
            console.log('ì†ì„± ëª©ë¡ ë¡œë“œ ì‹œì‘');
            try {
                $attributesList.innerHTML = '<div class="text-center text-muted">ë¡œë”© ì¤‘...</div>';
                
                // ëª¨ë“  ì†ì„± ëª©ë¡ ì¡°íšŒ
                const url = getServerUrl('/api/attributes/all');
                console.log('ì†ì„± ëª©ë¡ API ìš”ì²­', { url });
                const res = await fetch(url);

                console.log('ì†ì„± ëª©ë¡ API ì‘ë‹µ', { status: res.status });

                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}`);
                }

                const data = await res.json();
                console.log('ì†ì„± ëª©ë¡ ë°ì´í„° ìˆ˜ì‹ ', { ok: data.ok, attributeCount: data.attributes?.length || 0 });
                
                if (!data.ok || !data.attributes || data.attributes.length === 0) {
                    $attributesList.innerHTML = '<div class="text-center text-muted">ì €ì¥ëœ ì†ì„±ì´ ì—†ìŠµë‹ˆë‹¤.</div>';
                    return;
                }

                // í•„í„° ì…ë ¥ë€ì—ì„œ ì†Œì„¤ ì œëª©ê³¼ ì±•í„° ì •ë³´ íŒŒì‹±
                let currentNovelTitle = $novelTitle.value.trim();
                let currentChapter = currentChapterIdx !== null && chapters[currentChapterIdx] ? chapters[currentChapterIdx] : null;
                
                if ($attributeFilterInput && $attributeFilterInput.value.trim()) {
                    const filterText = $attributeFilterInput.value.trim();
                    console.log('í•„í„° ì…ë ¥ë€ ê°’:', filterText);
                    
                    // "â†’" êµ¬ë¶„ìë¡œ ì†Œì„¤ ì œëª©ê³¼ ì±•í„° íŒŒì‹±
                    // í˜•ì‹: "ì†Œì„¤ ì œëª© â†’ ì±•í„° ë²ˆí˜¸: ì±•í„° ì œëª©" ë˜ëŠ” "ì†Œì„¤ ì œëª© â†’ ì±•í„° ë²ˆí˜¸"
                    const arrowMatch = filterText.match(/^(.+?)\s*â†’\s*(.+)$/);
                    if (arrowMatch) {
                        currentNovelTitle = arrowMatch[1].trim();
                        const chapterPart = arrowMatch[2].trim();
                        
                        // ì±•í„° ë¶€ë¶„ íŒŒì‹±: "ì±•í„° 1: ê°œìš”" ë˜ëŠ” "ì±•í„° 1"
                        const chapterMatch = chapterPart.match(/^(.+?)(?::\s*(.+))?$/);
                        if (chapterMatch) {
                            currentChapter = {
                                number: chapterMatch[1].trim(),
                                title: chapterMatch[2] ? chapterMatch[2].trim() : '',
                                description: ''
                            };
                        } else {
                            currentChapter = {
                                number: chapterPart,
                                title: '',
                                description: ''
                            };
                        }
                        console.log('í•„í„° íŒŒì‹± ê²°ê³¼:', { currentNovelTitle, currentChapter });
                    } else {
                        // "â†’" êµ¬ë¶„ìê°€ ì—†ìœ¼ë©´ ì „ì²´ë¥¼ ì†Œì„¤ ì œëª©ìœ¼ë¡œ ì²˜ë¦¬
                        currentNovelTitle = filterText;
                        currentChapter = null;
                        console.log('í•„í„° íŒŒì‹± ê²°ê³¼ (ì†Œì„¤ ì œëª©ë§Œ):', { currentNovelTitle });
                    }
                }

                // ê° ì†ì„±ì˜ ë°ì´í„° ì¡°íšŒ
                const attributePromises = data.attributes.map(async (attr) => {
                            try {
                                const dataUrl = getServerUrl(`/api/attributes/data?bitMax=${attr.bitMax}&bitMin=${attr.bitMin}&limit=100`);
                                const dataRes = await fetch(dataUrl);
                                if (dataRes.ok) {
                                    const dataData = await dataRes.json();
                                    if (dataData.ok && dataData.items) {
                                // ì†ì„± ìì²´ë¥¼ ë°ì´í„°ë¡œ ì €ì¥í•œ ê²½ìš°ëŠ” ì œì™¸
                                        let dataList = dataData.items
                                            .filter(item => item.data && item.data.text && item.data.text !== attr.text);
                                        
                                console.log(`ì†ì„± "${attr.text}" ë°ì´í„° í•„í„°ë§ ì „:`, { count: dataList.length });
                                
                                // ì†Œì„¤ ì œëª©ê³¼ ì±•í„°ë¡œ ì—„ê²©í•˜ê²Œ í•„í„°ë§ (ì¼ì¹˜í•˜ëŠ” ë°ì´í„°ë§Œ í‘œì‹œ)
                                if (currentNovelTitle && currentChapter) {
                                    // ì •í™•íˆ ì¼ì¹˜í•˜ëŠ” ë°ì´í„°ë§Œ í‘œì‹œ
                                            dataList = dataList.filter(item => {
                                                const itemNovel = item.novel?.title;
                                                const itemChapter = item.chapter?.number;
                                                return itemNovel === currentNovelTitle && 
                                               itemChapter === currentChapter.number;
                                    });
                                    console.log(`í•„í„°ë§ í›„ (ì†Œì„¤+ì±•í„°):`, { 
                                        currentNovelTitle, 
                                        currentChapter: currentChapter.number,
                                        filteredCount: dataList.length 
                                    });
                                } else if (currentNovelTitle) {
                                    // ì†Œì„¤ ì œëª©ë§Œ ì¼ì¹˜í•˜ëŠ” ë°ì´í„° í‘œì‹œ
                                    dataList = dataList.filter(item => {
                                        const itemNovel = item.novel?.title;
                                        return itemNovel === currentNovelTitle;
                                    });
                                    console.log(`í•„í„°ë§ í›„ (ì†Œì„¤ë§Œ):`, { 
                                        currentNovelTitle,
                                        filteredCount: dataList.length 
                                    });
                                } else {
                                    // ì†Œì„¤ ì œëª©ì´ ì—†ìœ¼ë©´ ë°ì´í„° í‘œì‹œ ì•ˆ í•¨
                                    dataList = [];
                                    console.log('ì†Œì„¤ ì œëª© ì—†ìŒ, ë°ì´í„° í‘œì‹œ ì•ˆ í•¨');
                                }
                                
                                // data ê°ì²´ ì¶”ì¶œ (attribute ì •ë³´ë„ í•¨ê»˜ í¬í•¨)
                                const filteredDataList = dataList.map(item => {
                                    const dataItem = {
                                            ...item.data,
                                        // ì›ë³¸ itemì˜ attribute ì •ë³´ í¬í•¨ (log.ndjson êµ¬ì¡°ì— ë§ì¶¤)
                                            attribute: item.attribute || item.data?.attribute || null
                                    };
                                    // ë””ë²„ê¹…: attribute ì •ë³´ í™•ì¸
                                    if (item.attribute) {
                                        console.log(`ë°ì´í„°ì— attribute í¬í•¨:`, {
                                            attribute: item.attribute,
                                            dataText: item.data?.text?.substring(0, 50)
                                        });
                                    }
                                    return dataItem;
                                });
                                        
                                        return {
                                            ...attr,
                                            dataList: filteredDataList,
                                            dataCount: filteredDataList.length
                                        };
                                    }
                                }
                            } catch (e) {
                        console.warn(`ì†ì„± "${attr.text}" ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:`, e);
                            }
                            return {
                                ...attr,
                                dataList: [],
                                dataCount: 0
                            };
                        });
                        
                const attributesWithData = await Promise.all(attributePromises);
                console.log('ì†ì„± ë°ì´í„° ì¡°íšŒ ì™„ë£Œ', { count: attributesWithData.length });
                        
                // í•„í„° ì…ë ¥ë€ì˜ ê°’ìœ¼ë¡œ ì†ì„± ê²€ìƒ‰ (gpt_auto_newì˜ autoSearch í•¨ìˆ˜ì™€ ì™„ì „íˆ ë™ì¼í•œ ë¡œì§)
                let filteredAttributes = attributesWithData;
                
                        if ($attributeFilterInput && $attributeFilterInput.value.trim()) {
                            const filterText = $attributeFilterInput.value.trim();
                            const filterBits = calculateBitValues(filterText);
                            
                            if (filterBits.max !== null && filterBits.min !== null && filterBits.max && filterBits.min) {
                        console.log('ì†ì„± ìœ ì‚¬ë„ ê²€ìƒ‰ ì‹œì‘ (gpt_auto_new autoSearchì™€ ë™ì¼):', { filterText, filterBits });
                        
                        try {
                            // gpt_auto_newì˜ autoSearch í•¨ìˆ˜ì™€ ì™„ì „íˆ ë™ì¼í•œ ë¡œì§
                            // ê²€ìƒ‰ ì˜µì…˜: ê¸°ë³¸ê°’ 'attribute' (ì†ì„±ìœ¼ë¡œë§Œ ê²€ìƒ‰)
                            let searchOption = 'attribute';
                            
                            let searchResults = [];
                            const searchText = filterText;
                            
                            // 1. ì†ì„± ê²€ìƒ‰ (gpt_auto_new autoSearchì™€ ë™ì¼)
                            if (searchOption === 'attribute' || searchOption === 'all') {
                                try {
                                    // ê²€ìƒ‰ í…ìŠ¤íŠ¸ê°€ ìˆìœ¼ë©´ ê·¸ê²ƒì„ ìš°ì„  ì‚¬ìš©
                                    const searchAttributeText = searchText ? searchText.trim() : '';
                                    
                                    if (searchAttributeText) {
                                        const attrBits = calculateBitValues(searchAttributeText);
                                        if (attrBits.max && attrBits.min) {
                                            // ì†ì„± ìœ ì‚¬ë„ ê²€ìƒ‰ (thresholdë¡œ ìœ ì‚¬í•œ ì†ì„±ë“¤ì„ ì°¾ìŒ) - gpt_auto_newì™€ ë™ì¼
                                            const url = getServerUrl(`/api/attributes/data?bitMax=${attrBits.max}&bitMin=${attrBits.min}&limit=20&similarity=true&threshold=0.1`);
                                            const res = await fetch(url);

                                            if (res.ok) {
                                                const data = await res.json();
                                                if (data.ok && data.items) {
                                                    searchResults.push(...data.items.map(item => {
                                                        // ì†ì„± ê²€ìƒ‰ì¸ ê²½ìš°: ê²€ìƒ‰ ì¿¼ë¦¬ì˜ ì†ì„± BITì™€ ê²°ê³¼ì˜ ì†ì„± BITë¥¼ ë¹„êµ
                                                        const resultAttrBitMax = item.attribute?.bitMax || null;
                                                        const resultAttrBitMin = item.attribute?.bitMin || null;
                                                        const resultAttrText = item.attribute?.text || '';
                                                        
                                                        // ì†ì„± BITë¡œ ìœ ì‚¬ë„ ê³„ì‚° (ê³µí†µ ëª¨ë“ˆ ì‚¬ìš©) - gpt_auto_newì™€ ë™ì¼
                                                        const similarity = window.SearchAlgorithm.calculateAttributeSimilarity(
                                                            searchAttributeText,
                                                            attrBits.max,
                                                            attrBits.min,
                                                            item
                                                        );
                                                        
                                                        return {
                                                            ...item,
                                                            source: 'attribute_data',
                                                            input: item.attribute?.text || searchAttributeText,
                                                            response: item.data?.text || item.s || '',
                                                            similarity: similarity
                                                        };
                                                    }));
                                                }
                                            }
                                        }
                                    }
                                    
                                    // ì†ì„±ìœ¼ë¡œë§Œ ê²€ìƒ‰í•˜ëŠ” ê²½ìš°, ê²€ìƒ‰ í…ìŠ¤íŠ¸ BITë¡œ ëª¨ë“  ì†ì„±ê³¼ ìœ ì‚¬ë„ ë¹„êµ - gpt_auto_newì™€ ë™ì¼
                                    if (searchOption === 'attribute' && searchText && filterBits.max && filterBits.min) {
                            // ëª¨ë“  ì†ì„± ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
                            const allAttrUrl = getServerUrl('/api/attributes/all');
                            const allAttrRes = await fetch(allAttrUrl);
                            
                            if (allAttrRes.ok) {
                                const allAttrData = await allAttrRes.json();
                                if (allAttrData.ok && allAttrData.attributes && allAttrData.attributes.length > 0) {
                                                // ê²€ìƒ‰ í…ìŠ¤íŠ¸ BITì™€ ê° ì†ì„± BIT ê°„ì˜ ìœ ì‚¬ë„ ê³„ì‚° (ê³µí†µ ëª¨ë“ˆ ì‚¬ìš©) - gpt_auto_newì™€ ë™ì¼
                                    const similarAttributes = window.SearchAlgorithm.findSimilarAttributes(
                                                    searchText, 
                                        filterBits.max,
                                        filterBits.min,
                                        allAttrData.attributes,
                                        0.1,
                                        10
                                    );
                                    
                                                // ìœ ì‚¬í•œ ì†ì„±ë“¤ì˜ ë°ì´í„° ì¡°íšŒ - gpt_auto_newì™€ ë™ì¼
                                                for (const similarAttr of similarAttributes) {
                                                    try {
                                                        const dataUrl = getServerUrl(`/api/attributes/data?bitMax=${similarAttr.bitMax}&bitMin=${similarAttr.bitMin}&limit=5`);
                                                        const dataRes = await fetch(dataUrl);
                                                        
                                                        if (dataRes.ok) {
                                                            const dataData = await dataRes.json();
                                                            if (dataData.ok && dataData.items) {
                                                                searchResults.push(...dataData.items.map(item => ({
                                                                    ...item,
                                                                    source: 'attribute_similar',
                                                                    input: item.attribute?.text || similarAttr.text,
                                                                    response: item.data?.text || item.s || '',
                                                                    similarity: similarAttr.similarity * 0.9 // ì†ì„± ìœ ì‚¬ë„ì— ì•½ê°„ì˜ í˜ë„í‹° ì ìš©
                                                                })));
                                                            }
                                                        }
                                                    } catch (e) {
                                                        console.warn(`ì†ì„± "${similarAttr.text}" ë°ì´í„° ì¡°íšŒ ì˜¤ë¥˜:`, e);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } catch (e) {
                                    console.warn('ì†ì„± ë°ì´í„° ê²€ìƒ‰ ì˜¤ë¥˜:', e);
                                }
                            }
                            
                            // ì¶”ê°€ ê²€ìƒ‰: ì‰¼í‘œë¡œ êµ¬ë¶„ëœ í‚¤ì›Œë“œ ì²˜ë¦¬ (gpt_auto_newì™€ ë™ì¼)
                            const additionalKeywords = $additionalSearchInput && $additionalSearchInput.value.trim() 
                                ? $additionalSearchInput.value.trim().split(',').map(k => k.trim()).filter(k => k)
                                : [];
                            
                            if (additionalKeywords.length > 0 && searchText) {
                                // ê° ì¶”ê°€ í‚¤ì›Œë“œì— ëŒ€í•´ ê²€ìƒ‰ ìˆ˜í–‰
                                for (const additionalKeyword of additionalKeywords) {
                                    const combinedSearchText = `${searchText},${additionalKeyword}`;
                                    const combinedBits = calculateBitValues(combinedSearchText);
                                    
                                    if (combinedBits.max && combinedBits.min) {
                                        // ì¶”ê°€ ê²€ìƒ‰ ì‹¤í–‰ (ê¸°ë³¸ ê²€ìƒ‰ê³¼ ë™ì¼í•œ ë¡œì§)
                                        try {
                                            const combinedAttrBits = calculateBitValues(combinedSearchText);
                                            if (combinedAttrBits.max && combinedAttrBits.min) {
                                                const additionalUrl = getServerUrl(`/api/attributes/data?bitMax=${combinedAttrBits.max}&bitMin=${combinedAttrBits.min}&limit=20&similarity=true&threshold=0.1`);
                                                const additionalRes = await fetch(additionalUrl);
                                                
                                                if (additionalRes.ok) {
                                                    const additionalData = await additionalRes.json();
                                                    if (additionalData.ok && additionalData.items) {
                                                        searchResults.push(...additionalData.items.map(item => {
                                                            const similarity = window.SearchAlgorithm.calculateAttributeSimilarity(
                                                                combinedSearchText,
                                                                combinedAttrBits.max,
                                                                combinedAttrBits.min,
                                                                item
                                                            );
                                                            
                                        return {
                                                                ...item,
                                                                source: 'attribute_data',
                                                                input: item.attribute?.text || combinedSearchText,
                                                                response: item.data?.text || item.s || '',
                                                                similarity: similarity
                                                            };
                                                        }));
                                                    }
                                                }
                                                
                                                // ëª¨ë“  ì†ì„±ê³¼ ìœ ì‚¬ë„ ë¹„êµ
                                                const allAttrUrl = getServerUrl('/api/attributes/all');
                                                const allAttrRes = await fetch(allAttrUrl);
                                                
                                                if (allAttrRes.ok) {
                                                    const allAttrData = await allAttrRes.json();
                                                    if (allAttrData.ok && allAttrData.attributes && allAttrData.attributes.length > 0) {
                                                        const similarAttributes = window.SearchAlgorithm.findSimilarAttributes(
                                                            combinedSearchText,
                                                            combinedBits.max,
                                                            combinedBits.min,
                                                            allAttrData.attributes,
                                                            0.1,
                                                            10
                                                        );
                                                        
                                                        for (const similarAttr of similarAttributes) {
                                                            try {
                                                                const dataUrl = getServerUrl(`/api/attributes/data?bitMax=${similarAttr.bitMax}&bitMin=${similarAttr.bitMin}&limit=5`);
                                                                const dataRes = await fetch(dataUrl);
                                                                
                                                                if (dataRes.ok) {
                                                                    const dataData = await dataRes.json();
                                                                    if (dataData.ok && dataData.items) {
                                                                        searchResults.push(...dataData.items.map(item => ({
                                                                            ...item,
                                                                            source: 'attribute_similar',
                                                                            input: item.attribute?.text || similarAttr.text,
                                                                            response: item.data?.text || item.s || '',
                                                                            similarity: similarAttr.similarity * 0.9
                                                                        })));
                                                                    }
                                                                }
                                } catch (e) {
                                                                console.warn(`ì†ì„± "${similarAttr.text}" ë°ì´í„° ì¡°íšŒ ì˜¤ë¥˜:`, e);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        } catch (e) {
                                            console.warn(`ì¶”ê°€ ê²€ìƒ‰ í‚¤ì›Œë“œ "${additionalKeyword}" ì²˜ë¦¬ ì˜¤ë¥˜:`, e);
                                        }
                                    }
                                }
                            }

                            // ì¤‘ë³µ ì œê±° ë° ì •ë ¬ (ê³µí†µ ëª¨ë“ˆ ì‚¬ìš©) - gpt_auto_newì™€ ë™ì¼
                            let finalResults = window.SearchAlgorithm.processSearchResults(searchResults, filterBits.max, filterBits.min, 50);
                            
                            // ê²€ìƒ‰ í…ìŠ¤íŠ¸ê°€ ìˆì„ ë•Œ í…ìŠ¤íŠ¸ ì •í™• ë§¤ì¹­ ìš°ì„  ì •ë ¬ - gpt_auto_newì™€ ë™ì¼
                            if (searchText && searchText.trim()) {
                                const searchTextTrimmed = searchText.trim();
                                finalResults = finalResults.sort((a, b) => {
                                    const aAttrText = (a.attribute?.text || a.input || '').trim();
                                    const bAttrText = (b.attribute?.text || b.input || '').trim();
                                    
                                    // í…ìŠ¤íŠ¸ê°€ ì •í™•íˆ ì¼ì¹˜í•˜ê±°ë‚˜ í¬í•¨ë˜ëŠ” ê²½ìš° ìš°ì„ 
                                    const aExactMatch = aAttrText === searchTextTrimmed || aAttrText.includes(searchTextTrimmed);
                                    const bExactMatch = bAttrText === searchTextTrimmed || bAttrText.includes(searchTextTrimmed);
                                    
                                    if (aExactMatch && !bExactMatch) return -1;
                                    if (!aExactMatch && bExactMatch) return 1;
                                    
                                    // ë‘˜ ë‹¤ ì •í™•íˆ ì¼ì¹˜í•˜ê±°ë‚˜ ë‘˜ ë‹¤ ì•„ë‹Œ ê²½ìš° ìœ ì‚¬ë„ìˆœ ì •ë ¬
                                    return (b.similarity || 0) - (a.similarity || 0);
                                });
                            }
                            
                            // ê²€ìƒ‰ ê²°ê³¼ë¥¼ ì†ì„± í˜•ì‹ìœ¼ë¡œ ë³€í™˜ (novel_composition_new2 í˜•ì‹ì— ë§ì¶¤)
                            const attributeMap = new Map();
                            finalResults.forEach(item => {
                                const attrText = item.attribute?.text || item.input || '';
                                const attrBitMax = item.attribute?.bitMax || null;
                                const attrBitMin = item.attribute?.bitMin || null;
                                
                                if (attrText && attrBitMax !== null && attrBitMin !== null) {
                                    const key = `${attrBitMax}_${attrBitMin}`;
                                    if (!attributeMap.has(key)) {
                                        // ë°ì´í„° ì¬ì¡°íšŒ (novel_composition_new2 í˜•ì‹ì— ë§ì¶¤, attribute ì •ë³´ í¬í•¨)
                                        const dataList = item.data?.text ? [{
                                            text: item.data.text,
                                            bitMax: item.data.bitMax || item.bitMax || null,
                                            bitMin: item.data.bitMin || item.bitMin || null,
                                            // ì›ë³¸ itemì˜ attribute ì •ë³´ í¬í•¨ (log.ndjson êµ¬ì¡°ì— ë§ì¶¤)
                                            attribute: item.attribute || item.data?.attribute || null
                                        }] : [];
                                        
                                        attributeMap.set(key, {
                                            text: attrText,
                                            bitMax: attrBitMax,
                                            bitMin: attrBitMin,
                                            dataList: dataList,
                                            dataCount: dataList.length,
                                            similarity: item.similarity || 0
                                        });
                                    } else {
                                        // ê¸°ì¡´ ì†ì„±ì— ë°ì´í„° ì¶”ê°€
                                        const existing = attributeMap.get(key);
                                        if (item.data?.text) {
                                            existing.dataList.push({
                                                text: item.data.text,
                                                bitMax: item.data.bitMax || item.bitMax || null,
                                                bitMin: item.data.bitMin || item.bitMin || null,
                                                // ì›ë³¸ itemì˜ attribute ì •ë³´ í¬í•¨ (log.ndjson êµ¬ì¡°ì— ë§ì¶¤)
                                                attribute: item.attribute || item.data?.attribute || null
                                            });
                                            existing.dataCount = existing.dataList.length;
                                        }
                                    }
                                }
                            });
                            
                            // ì†ì„±ë³„ë¡œ ë°ì´í„° ì¬ì¡°íšŒ (limit=100ìœ¼ë¡œ ëª¨ë“  ë°ì´í„° ê°€ì ¸ì˜¤ê¸°)
                            const similarAttributePromises = Array.from(attributeMap.values()).map(async (attr) => {
                            try {
                                const dataUrl = getServerUrl(`/api/attributes/data?bitMax=${attr.bitMax}&bitMin=${attr.bitMin}&limit=100`);
                                const dataRes = await fetch(dataUrl);
                                if (dataRes.ok) {
                                    const dataData = await dataRes.json();
                                    if (dataData.ok && dataData.items) {
                                                    // ì†ì„± ìì²´ë¥¼ ë°ì´í„°ë¡œ ì €ì¥í•œ ê²½ìš°ëŠ” ì œì™¸
                                        let dataList = dataData.items
                                                .filter(item => item.data && item.data.text && item.data.text !== attr.text)
                                                .map(item => ({
                                            ...item.data,
                                                    // ì›ë³¸ itemì˜ attribute ì •ë³´ í¬í•¨ (log.ndjson êµ¬ì¡°ì— ë§ì¶¤)
                                            attribute: item.attribute || item.data?.attribute || null
                                        }));
                                        
                                        return {
                                            ...attr,
                                                dataList: dataList,
                                                dataCount: dataList.length,
                                                similarity: attr.similarity
                                        };
                                    }
                                }
                            } catch (e) {
                                    console.warn(`ì†ì„± "${attr.text}" ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:`, e);
                            }
                            return {
                                ...attr,
                                    dataList: attr.dataList || [],
                                    dataCount: attr.dataList?.length || 0,
                                    similarity: attr.similarity
                            };
                        });
                    
                                    // ìœ ì‚¬í•œ ì†ì„±ë“¤ì˜ ë°ì´í„° ì¬ì¡°íšŒ ì™„ë£Œ
                                    const similarAttributesWithData = await Promise.all(similarAttributePromises);
                            
                            // gpt_auto_newì™€ ë™ì¼í•œ ì •ë ¬ ìˆœì„œ ì ìš© (finalResults ìˆœì„œ ìœ ì§€)
                            // finalResultsì˜ ìˆœì„œë¥¼ ìœ ì§€í•˜ë©´ì„œ ì†ì„±ë³„ë¡œ ê·¸ë£¹í™”ëœ ê²°ê³¼ ì •ë ¬
                            const finalResultsOrder = new Map();
                            finalResults.forEach((item, idx) => {
                                const attrText = item.attribute?.text || item.input || '';
                                const attrBitMax = item.attribute?.bitMax || null;
                                const attrBitMin = item.attribute?.bitMin || null;
                                if (attrText && attrBitMax !== null && attrBitMin !== null) {
                                    const key = `${attrBitMax}_${attrBitMin}`;
                                    if (!finalResultsOrder.has(key)) {
                                        finalResultsOrder.set(key, idx);
                                    }
                                }
                            });
                            
                            filteredAttributes = similarAttributesWithData.sort((a, b) => {
                                const keyA = `${a.bitMax}_${a.bitMin}`;
                                const keyB = `${b.bitMax}_${b.bitMin}`;
                                const orderA = finalResultsOrder.get(keyA) ?? 999999;
                                const orderB = finalResultsOrder.get(keyB) ?? 999999;
                                
                                // finalResultsì˜ ìˆœì„œ ìš°ì„ 
                                if (orderA !== orderB) {
                                    return orderA - orderB;
                                }
                                
                                // ê°™ì€ ìˆœì„œì¸ ê²½ìš° ìœ ì‚¬ë„ìˆœ ì •ë ¬ (gpt_auto_newì™€ ë™ì¼)
                                return (b.similarity || 0) - (a.similarity || 0);
                            });
                            
                            console.log('ì†ì„± ìœ ì‚¬ë„ ê²€ìƒ‰ ì™„ë£Œ (gpt_auto_new autoSearchì™€ ë™ì¼):', { 
                                        filterText, 
                                        before: attributesWithData.length, 
                                        after: filteredAttributes.length 
                                });
                            } catch (e) {
                            console.warn('ì†ì„± ìœ ì‚¬ë„ ê²€ìƒ‰ ì˜¤ë¥˜:', e);
                            // ì˜¤ë¥˜ ë°œìƒ ì‹œ ì›ë³¸ ëª©ë¡ ìœ ì§€
                            filteredAttributes = attributesWithData;
                        }
                    } else {
                        console.warn('í•„í„° í…ìŠ¤íŠ¸ BIT ê³„ì‚° ì‹¤íŒ¨');
                        filteredAttributes = [];
                    }
                }

                // ê²€ìƒ‰ ê²°ê³¼ í•„í„°ë§ ì ìš© (ë¶„ë¦¬ëœ í•¨ìˆ˜ ì‚¬ìš©)
                let displayAttributes = filteredAttributes;
                const searchFilterValue = $searchFilterInput ? $searchFilterInput.value.trim() : '';
                if (searchFilterValue) {
                    console.log('ê²€ìƒ‰ ê²°ê³¼ í•„í„°ë§ ì ìš© ì‹œì‘', { 
                        filterKeyword: searchFilterValue, 
                        totalBeforeFilter: filteredAttributes.length 
                    });
                    
                    // ì†ì„± ë ˆë²¨ í•„í„°ë§
                    displayAttributes = filterAttributesByKeyword(filteredAttributes, searchFilterValue);
                    
                    console.log('ê²€ìƒ‰ ê²°ê³¼ í•„í„°ë§ ì ìš© ì™„ë£Œ', { 
                        filterKeyword: searchFilterValue, 
                        totalBeforeFilter: filteredAttributes.length,
                        totalAfterFilter: displayAttributes.length
                    });
                }

                // ì†ì„± ëª©ë¡ ë Œë”ë§
                console.log('ì†ì„± ëª©ë¡ ë Œë”ë§ ì‹œì‘', { 
                    total: filteredAttributes.length, 
                    filtered: displayAttributes.length,
                    filterKeyword: searchFilterValue || '(ì—†ìŒ)'
                });
                
                let html = '';
                if (currentNovelTitle && currentChapter) {
                    html += `<div class="mb-2 p-2 bg-light rounded"><small class="text-muted">ğŸ“– ${escapeHtml(currentNovelTitle)} â†’ ${escapeHtml(currentChapter.number || 'ì±•í„°')}: ${escapeHtml(currentChapter.title || 'ì œëª© ì—†ìŒ')}</small></div>`;
                } else if (currentNovelTitle) {
                    html += `<div class="mb-2 p-2 bg-light rounded"><small class="text-muted">ğŸ“– ${escapeHtml(currentNovelTitle)} (ì±•í„° ë¯¸ì„ íƒ)</small></div>`;
                } else {
                    html += `<div class="mb-2 p-2 bg-warning rounded"><small class="text-danger">âš ï¸ ì†Œì„¤ ì œëª©ì„ ì…ë ¥í•˜ê³  ì±•í„°ë¥¼ ì…ë ¥í•˜ì„¸ìš”.</small></div>`;
                }

                if (displayAttributes.length === 0) {
                    if ($attributeFilterInput && $attributeFilterInput.value.trim()) {
                    html += `<div class="mb-2 p-2 bg-light rounded"><small class="text-muted">"${escapeHtml($attributeFilterInput.value.trim())}"ì™€ ìœ ì‚¬í•œ ì†ì„±ì´ ì—†ìŠµë‹ˆë‹¤. (ìœ ì‚¬ë„ ì„ê³„ê°’: 0.1 ì´ìƒ)</small></div>`;
                    } else if (searchFilterValue) {
                        html += `<div class="mb-2 p-2 bg-light rounded"><small class="text-muted">ê²€ìƒ‰ ê²°ê³¼ì— "${escapeHtml(searchFilterValue)}" í‚¤ì›Œë“œê°€ í¬í•¨ëœ í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤.</small></div>`;
                    } else {
                        html += `<div class="mb-2 p-2 bg-light rounded"><small class="text-muted">í‘œì‹œí•  ì†ì„±ì´ ì—†ìŠµë‹ˆë‹¤.</small></div>`;
                    }
                }
                
                displayAttributes.forEach((attr) => {
                    // ì†ì„± í…ìŠ¤íŠ¸ íŒŒì‹±
                    let attributeText = attr.text || '';
                    const arrowParts = attributeText.split(' â†’ ');
                    
                    // ì±•í„° êµ¬ì„±ì´ í¬í•¨ë˜ì–´ ìˆì§€ ì•Šìœ¼ë©´ í‘œì‹œí•˜ì§€ ì•ŠìŒ (â†’ ê°€ 1ê°œ ì´ìƒì´ì–´ì•¼ í•¨, ì¦‰ ìµœì†Œ "ì†Œì„¤ ì œëª© â†’ ì±•í„°" í˜•ì‹)
                    // í”„ë¡¬í”„íŠ¸ 2 í˜•ì‹: "ë‹¤í¬ íŒíƒ€ì§€ â†’ ì±•í„° 3: ì œ2ì¥" (â†’ 1ê°œ)
                    // í”„ë¡¬í”„íŠ¸ 1 í˜•ì‹: "ë‹¤í¬ íŒíƒ€ì§€ â†’ ì±•í„° 3: ì œ2ì¥ â†’ ë“±ì¥ì¸ë¬¼" (â†’ 2ê°œ)
                    if (arrowParts.length < 2) {
                        return; // ì´ ì†ì„±ì€ ìŠ¤í‚µ
                    }
                    
                    // ê²€ìƒ‰ ê²°ê³¼ í•„í„°ë§: ë°ì´í„° ë ˆë²¨ í•„í„°ë§ (ë¶„ë¦¬ëœ í•¨ìˆ˜ ì‚¬ìš©, ê°•í™”ëœ í•„í„°ë§)
                    let filteredDataList = attr.dataList || [];
                    
                    // í•„í„°ê°€ ìˆëŠ” ê²½ìš°ë§Œ ë°ì´í„° ë ˆë²¨ í•„í„°ë§ ì ìš©
                    if (searchFilterValue && searchFilterValue.trim()) {
                        filteredDataList = filterDataListByKeyword(
                            filteredDataList, 
                            searchFilterValue, 
                            attributeText
                        );
                        
                        // í•„í„°ë§ í›„ ë¡œê·¸ (ë””ë²„ê¹…ìš©)
                        if (filteredDataList.length !== (attr.dataList || []).length) {
                            console.log('ë°ì´í„° ë ˆë²¨ í•„í„°ë§ ì ìš©:', {
                                attributeText: attributeText.substring(0, 50),
                                filterKeyword: searchFilterValue,
                                before: (attr.dataList || []).length,
                                after: filteredDataList.length,
                                filteredData: filteredDataList.map(d => ({
                                    hasAttribute: !!d.attribute,
                                    attributeText: d.attribute?.text || d.attribute || '',
                                    dataPreview: (d.text || '').substring(0, 30)
                                }))
                            });
                        }
                    }
                    
                    // ì¤‘ë³µëœ ë‹¨ì–´ ì œê±° (ìˆœì„œ ìœ ì§€í•˜ë©´ì„œ ì „ì²´ ë°°ì—´ì—ì„œ ì¤‘ë³µ ì œê±°)
                    const uniqueParts = [];
                    const seenParts = new Set();
                    for (let i = 0; i < arrowParts.length; i++) {
                        const currentPart = arrowParts[i].trim();
                        // ì´ë¯¸ ë³¸ ì ì´ ì—†ëŠ” ë¶€ë¶„ë§Œ ì¶”ê°€ (ìˆœì„œ ìœ ì§€)
                        if (!seenParts.has(currentPart)) {
                            uniqueParts.push(currentPart);
                            seenParts.add(currentPart);
                        }
                    }
                    
                    // ì¤‘ë³µ ì œê±°ëœ ì†ì„± í…ìŠ¤íŠ¸ ì¬êµ¬ì„±
                    const fullAttributeText = uniqueParts.join(' â†’ ');
                    
                    // ìœ ì‚¬ë„ í‘œì‹œ (í•„í„° ì…ë ¥ì´ ìˆëŠ” ê²½ìš°)
                    const similarityBadge = ($attributeFilterInput && $attributeFilterInput.value.trim() && attr.similarity !== undefined) 
                        ? `<span class="badge ${attr.similarity >= 0.9 ? 'bg-success' : attr.similarity >= 0.7 ? 'bg-warning' : 'bg-info'} ms-2">ìœ ì‚¬ë„ ${(attr.similarity * 100).toFixed(10)}%</span>`
                        : '';
                    
                    html += `
                        <div class="attribute-item" 
                             data-bit-max="${attr.bitMax}" 
                             data-bit-min="${attr.bitMin}"
                             data-attribute-text="${escapeHtml(attr.text)}">
                            <div class="attribute-header">
                                <div style="text-align: left;">
                                    <span class="attribute-name">${escapeHtml(fullAttributeText)}</span>
                                    ${similarityBadge}
                                </div>
                                <div style="text-align: left; margin-top: 5px;">
                                <small class="text-muted">
                                        BIT: ${attr.bitMax.toFixed(15)}, ${attr.bitMin.toFixed(15)} | ë°ì´í„° ${attr.dataCount}ê°œ
                                </small>
                                </div>
                            </div>
                            <div class="data-list">
                                ${filteredDataList.length > 0 ? filteredDataList.map((data, dataIdx) => {
                                    const fullText = data.text || '';
                                    const displayText = fullText.length > 150 ? fullText.substring(0, 150) + '...' : fullText;
                                    const uniqueId = `data-${attr.bitMax}-${attr.bitMin}-${dataIdx}`;
                                    // í…ìŠ¤íŠ¸ë¥¼ JSON.stringifyë¡œ ì•ˆì „í•˜ê²Œ ì¸ì½”ë”©
                                    const safeText = JSON.stringify(fullText);
                                    // ì‚­ì œ í™•ì¸ìš© ì•ˆì „í•œ ë¯¸ë¦¬ë³´ê¸° í…ìŠ¤íŠ¸ (HTML ì´ìŠ¤ì¼€ì´í”„)
                                    const safePreview = escapeHtml(fullText.substring(0, 50));
                                    
                                    // ë°ì´í„°ì˜ attribute ì •ë³´ í‘œì‹œ (log.ndjson êµ¬ì¡°: item.attribute.text)
                                    let dataAttributeText = '';
                                    
                                    // ë””ë²„ê¹…: ì „ì²´ data ê°ì²´ í™•ì¸
                                    console.log('ë°ì´í„° ê°ì²´ í™•ì¸:', {
                                        hasAttribute: !!data.attribute,
                                        attribute: data.attribute,
                                        attributeType: typeof data.attribute,
                                        keys: Object.keys(data)
                                    });
                                    
                                    if (data.attribute) {
                                        if (typeof data.attribute === 'object' && data.attribute !== null) {
                                            dataAttributeText = data.attribute.text || data.attribute.toString();
                                        } else if (typeof data.attribute === 'string') {
                                            dataAttributeText = data.attribute;
                                        }
                                    }
                                    
                                    // ë””ë²„ê¹…: attribute ì •ë³´ í™•ì¸
                                    if (dataAttributeText) {
                                        console.log('ë°ì´í„° attribute ì •ë³´ ì¶”ì¶œ ì„±ê³µ:', {
                                            attributeText: dataAttributeText,
                                            dataText: fullText.substring(0, 30)
                                        });
                                    } else {
                                        console.log('ë°ì´í„° attribute ì •ë³´ ì—†ìŒ:', {
                                            data: data,
                                            hasAttribute: !!data.attribute
                                        });
                                    }
                                    
                                    const dataAttributeHtml = dataAttributeText 
                                        ? `<div class="small text-info mb-2" style="background-color: #e7f3ff; padding: 5px; border-radius: 3px; margin-bottom: 8px;"><strong>ì†ì„±:</strong> ${escapeHtml(dataAttributeText)}</div>` 
                                        : '';
                                    
                                    return `
                                    <div class="data-item">
                                        ${dataAttributeHtml}
                                        <strong style="word-break: break-word; display: block; margin-bottom: 8px;">${escapeHtml(displayText)}</strong>
                                        <div class="d-flex justify-content-between align-items-start">
                                            <small class="text-muted">
                                                BIT: ${data.bitMax.toFixed(15)}, ${data.bitMin.toFixed(15)}
                                        </small>
                                            <div class="d-flex flex-column gap-1">
                                            <button class="btn btn-sm btn-outline-secondary" 
                                                    onclick="copyDataTextFromHidden('${uniqueId}'); return false;"
                                                    title="ì „ì²´ í…ìŠ¤íŠ¸ ë³µì‚¬">
                                                ğŸ“‹ ë³µì‚¬
                                            </button>
                                                <button class="btn btn-sm btn-outline-success input-data-btn" 
                                                        data-text="${escapeHtml(fullText).replace(/"/g, '&quot;')}"
                                                        title="ë¶„ì„ ì…ë ¥ìœ¼ë¡œ ë³´ë‚´ê¸°">
                                                    â†˜ ì…ë ¥
                                                </button>
                                                <button class="btn btn-sm btn-outline-primary edit-data-btn" 
                                                        data-attr-bit-max="${attr.bitMax}"
                                                        data-attr-bit-min="${attr.bitMin}"
                                                        data-bit-max="${data.bitMax}"
                                                        data-bit-min="${data.bitMin}"
                                                        data-text="${escapeHtml(fullText).replace(/"/g, '&quot;')}"
                                                        title="ë°ì´í„° ìˆ˜ì •">
                                                    âœï¸ ìˆ˜ì •
                                            </button>
                                                <button class="btn btn-sm btn-outline-danger delete-data-btn" 
                                                        data-attr-bit-max="${attr.bitMax}"
                                                        data-attr-bit-min="${attr.bitMin}"
                                                        data-bit-max="${data.bitMax}"
                                                        data-bit-min="${data.bitMin}"
                                                        data-text="${escapeHtml(fullText).replace(/"/g, '&quot;')}"
                                                        title="ë°ì´í„° ì‚­ì œ">
                                                    ğŸ—‘ï¸ ì‚­ì œ
                                            </button>
                                            </div>
                                    </div>
                                        <input type="hidden" id="${uniqueId}" value="${escapeHtml(fullText).replace(/"/g, '&quot;')}">
                                    </div>
                                `;
                                }).join('') : '<div class="text-muted small">ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</div>'}
                            </div>
                        </div>
                    `;
                });

                $attributesList.innerHTML = html;
                console.log('ì†ì„± ëª©ë¡ ë Œë”ë§ ì™„ë£Œ', { renderedCount: filteredAttributes.length, total: attributesWithData.length });
                
                // ìˆ˜ì • ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
                $attributesList.querySelectorAll('.edit-data-btn').forEach(btn => {
                    btn.addEventListener('click', function(e) {
                        e.preventDefault();
                        const attrBitMax = parseFloat(this.getAttribute('data-attr-bit-max'));
                        const attrBitMin = parseFloat(this.getAttribute('data-attr-bit-min'));
                        const dataBitMax = parseFloat(this.getAttribute('data-bit-max'));
                        const dataBitMin = parseFloat(this.getAttribute('data-bit-min'));
                        const dataText = this.getAttribute('data-text') || '';
                        
                        // HTML ì—”í‹°í‹° ë””ì½”ë”©
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = dataText.replace(/&quot;/g, '"');
                        const decodedText = tempDiv.textContent || tempDiv.innerText || dataText;
                        
                        openEditDataModal(attrBitMax, attrBitMin, dataBitMax, dataBitMin, decodedText);
                    });
                });
                
                // ì‚­ì œ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
                $attributesList.querySelectorAll('.delete-data-btn').forEach(btn => {
                    btn.addEventListener('click', function(e) {
                        e.preventDefault();
                        const attrBitMax = parseFloat(this.getAttribute('data-attr-bit-max'));
                        const attrBitMin = parseFloat(this.getAttribute('data-attr-bit-min'));
                        const dataBitMax = parseFloat(this.getAttribute('data-bit-max'));
                        const dataBitMin = parseFloat(this.getAttribute('data-bit-min'));
                        const dataText = this.getAttribute('data-text') || '';
                        deleteAttributeData(attrBitMax, attrBitMin, dataBitMax, dataBitMin, dataText);
                    });
                });

                // ì…ë ¥ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡ (ë¶„ì„ ì…ë ¥ë€ìœ¼ë¡œ ë³µì‚¬)
                $attributesList.querySelectorAll('.input-data-btn').forEach(btn => {
                    btn.addEventListener('click', function(e) {
                        e.preventDefault();
                        try {
                            const dataText = this.getAttribute('data-text') || '';
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = dataText.replace(/&quot;/g, '"');
                            const decodedText = tempDiv.textContent || tempDiv.innerText || dataText;
                            if ($gptInput) {
                                $gptInput.value = decodedText;
                                $gptInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }
                            if ($gptStatus) {
                                $gptStatus.textContent = 'âœ“ ë°ì´í„°ê°€ ë¶„ì„ ì…ë ¥ë€ì— ì±„ì›Œì¡ŒìŠµë‹ˆë‹¤.';
                                $gptStatus.style.color = '#28a745';
                            }
                            console.log('ë¶„ì„ ì…ë ¥ë€ìœ¼ë¡œ ë°ì´í„° ì…ë ¥ ì™„ë£Œ');
                        } catch (err) {
                            console.error('ë¶„ì„ ì…ë ¥ë€ìœ¼ë¡œ ì…ë ¥ ì‹¤íŒ¨:', err);
                            if ($gptStatus) {
                                $gptStatus.textContent = 'âœ— ì…ë ¥ ì‹¤íŒ¨';
                                $gptStatus.style.color = '#dc3545';
                            }
                        }
                    });
                });
            } catch (e) {
                console.error('ì†ì„± ëª©ë¡ ë¡œë“œ ì˜¤ë¥˜:', e);
                $attributesList.innerHTML = `<div class="text-danger">âœ— ë¡œë“œ ì‹¤íŒ¨: ${e.message}</div>`;
            }
        }

        // localStorage í‚¤ ìƒìˆ˜
        const STORAGE_KEY_ATTRIBUTE_FILTER = 'novel_composition_new2_attribute_filter';
        const STORAGE_KEY_ADDITIONAL_SEARCH = 'novel_composition_new2_additional_search';
        
        // ì¶”ê°€ ê²€ìƒ‰ ê¸°ë³¸ê°’
        const DEFAULT_ADDITIONAL_SEARCH = 'ë“±ì¥ì¸ë¬¼,í…Œë§ˆ/ì£¼ì œ,ì£¼ìš” ì‚¬ê±´,ë°°ê²½ ì„¤ì •,ê°ì •/ë¶„ìœ„ê¸°';

        // localStorageì—ì„œ ê²€ìƒ‰ ì„¤ì • ë¡œë“œ
        function loadSearchSettingsFromStorage() {
            try {
                const savedAttributeFilter = localStorage.getItem(STORAGE_KEY_ATTRIBUTE_FILTER);
                if (savedAttributeFilter && $attributeFilterInput) {
                    $attributeFilterInput.value = savedAttributeFilter;
                    // ë™ê¸°í™” í•¨ìˆ˜ê°€ ì •ì˜ë˜ì–´ ìˆìœ¼ë©´ í˜¸ì¶œ
                    if (typeof syncAttributeFilterToSearchFilter === 'function') {
                        syncAttributeFilterToSearchFilter();
                    }
                }
                
                const savedAdditionalSearch = localStorage.getItem(STORAGE_KEY_ADDITIONAL_SEARCH);
                if ($additionalSearchInput) {
                    // localStorageì— ì €ì¥ëœ ê°’ì´ ìˆìœ¼ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ ì‚¬ìš©
                    $additionalSearchInput.value = savedAdditionalSearch || DEFAULT_ADDITIONAL_SEARCH;
                    // ê¸°ë³¸ê°’ì„ ì‚¬ìš©í•œ ê²½ìš° localStorageì— ì €ì¥
                    if (!savedAdditionalSearch) {
                        localStorage.setItem(STORAGE_KEY_ADDITIONAL_SEARCH, DEFAULT_ADDITIONAL_SEARCH);
                    }
                }
                
                const savedSearchFilter = localStorage.getItem(STORAGE_KEY_SEARCH_FILTER);
                // ì†ì„± í•„í„° ê°’ì´ ìˆìœ¼ë©´ ê·¸ê²ƒì„ ìš°ì„  ì‚¬ìš© (ì–‘ë°©í–¥ ë™ê¸°í™”)
                if ($attributeFilterInput && $attributeFilterInput.value.trim() && $searchFilterInput) {
                    $searchFilterInput.value = $attributeFilterInput.value.trim();
                } else if (savedSearchFilter && $searchFilterInput) {
                    $searchFilterInput.value = savedSearchFilter;
                    // ê²€ìƒ‰ ê²°ê³¼ í•„í„°ë§ ê°’ì´ ìˆìœ¼ë©´ ì†ì„± í•„í„°ì—ë„ ë™ê¸°í™”
                    if ($attributeFilterInput) {
                        $attributeFilterInput.value = savedSearchFilter;
                        // ì†ì„± í•„í„° ë³€ê²½ ì‹œ ê²€ìƒ‰ ê²°ê³¼ í•„í„°ë§ ë™ê¸°í™”
                        if (typeof syncAttributeFilterToSearchFilter === 'function') {
                            syncAttributeFilterToSearchFilter();
                        }
                    }
                }
            } catch (e) {
                console.warn('ê²€ìƒ‰ ì„¤ì • ë¡œë“œ ì˜¤ë¥˜:', e);
            }
        }

        // localStorageì— ê²€ìƒ‰ ì„¤ì • ì €ì¥
        function saveSearchSettingsToStorage() {
            try {
                if ($attributeFilterInput) {
                    localStorage.setItem(STORAGE_KEY_ATTRIBUTE_FILTER, $attributeFilterInput.value.trim());
                }
                
                if ($additionalSearchInput) {
                    localStorage.setItem(STORAGE_KEY_ADDITIONAL_SEARCH, $additionalSearchInput.value.trim());
                }
                
                if ($searchFilterInput) {
                    localStorage.setItem(STORAGE_KEY_SEARCH_FILTER, $searchFilterInput.value.trim());
                }
            } catch (e) {
                console.warn('ê²€ìƒ‰ ì„¤ì • ì €ì¥ ì˜¤ë¥˜:', e);
            }
        }

        // ì†ì„± í•„í„°ì™€ ê²€ìƒ‰ ê²°ê³¼ í•„í„°ë§ ë™ê¸°í™” í•¨ìˆ˜ (ì „ì—­ì—ì„œ ì‚¬ìš© ê°€ëŠ¥í•˜ë„ë¡)
        function syncAttributeFilterToSearchFilter() {
            if ($attributeFilterInput && $searchFilterInput) {
                const newValue = $attributeFilterInput.value.trim();
                if ($searchFilterInput.value.trim() !== newValue) {
                    $searchFilterInput.value = newValue;
                    if (typeof saveSearchSettingsToStorage === 'function') {
                        saveSearchSettingsToStorage();
                    }
                }
            }
        }

        // ì†ì„± ê²€ìƒ‰ í•„í„° ì…ë ¥ ì´ë²¤íŠ¸
        if ($attributeFilterInput) {
            let filterTimer = null;
            
            // input ì´ë²¤íŠ¸: ì‚¬ìš©ìê°€ ì§ì ‘ ì…ë ¥í•˜ëŠ” ê²½ìš°
            $attributeFilterInput.addEventListener('input', () => {
                // localStorage ìë™ ì €ì¥
                saveSearchSettingsToStorage();
                
                // ê²€ìƒ‰ ê²°ê³¼ í•„í„°ë§ ì…ë ¥ë€ì— ìë™ìœ¼ë¡œ ì†ì„± í•„í„° ê°’ ë™ê¸°í™”
                syncAttributeFilterToSearchFilter();
                
                // ë””ë°”ìš´ì‹±ìœ¼ë¡œ ìë™ ë¡œë“œ
                if (filterTimer) clearTimeout(filterTimer);
                filterTimer = setTimeout(() => {
                    loadAttributes();
                }, 500);
            });
            
            // change ì´ë²¤íŠ¸: ê°’ì´ ë³€ê²½ë˜ëŠ” ëª¨ë“  ê²½ìš° (ì˜ˆ: í”„ë¡œê·¸ë¨ì ìœ¼ë¡œ ë³€ê²½)
            $attributeFilterInput.addEventListener('change', () => {
                // ê²€ìƒ‰ ê²°ê³¼ í•„í„°ë§ ì…ë ¥ë€ì— ìë™ìœ¼ë¡œ ì†ì„± í•„í„° ê°’ ë™ê¸°í™”
                syncAttributeFilterToSearchFilter();
                // localStorage ìë™ ì €ì¥
                saveSearchSettingsToStorage();
            });
        }

        // ì¶”ê°€ ê²€ìƒ‰ ì…ë ¥ ì´ë²¤íŠ¸
        if ($additionalSearchInput) {
            let additionalSearchTimer = null;
            $additionalSearchInput.addEventListener('input', () => {
                // localStorage ìë™ ì €ì¥
                saveSearchSettingsToStorage();
                
                // í•„í„° ì…ë ¥ì´ ìˆìœ¼ë©´ ì¬ê²€ìƒ‰
                if ($attributeFilterInput && $attributeFilterInput.value.trim()) {
                    if (additionalSearchTimer) clearTimeout(additionalSearchTimer);
                    additionalSearchTimer = setTimeout(() => {
                        loadAttributes();
                    }, 500);
                }
            });
        }

        // ê²€ìƒ‰ ê²°ê³¼ í•„í„°ë§ ì´ë²¤íŠ¸
        if ($searchFilterInput) {
            let filterTimer = null;
            $searchFilterInput.addEventListener('input', () => {
                // ì†ì„± í•„í„° ì…ë ¥ë€ì— ìë™ìœ¼ë¡œ ê²€ìƒ‰ ê²°ê³¼ í•„í„°ë§ ê°’ ë™ê¸°í™”
                if ($attributeFilterInput) {
                    $attributeFilterInput.value = $searchFilterInput.value.trim();
                    saveSearchSettingsToStorage();
                }
                
                // ë””ë°”ìš´ì‹±ìœ¼ë¡œ í•„í„°ë§ ì¬ì ìš©
                if (filterTimer) clearTimeout(filterTimer);
                filterTimer = setTimeout(() => {
                    // ì†ì„± ëª©ë¡ ì¬ë Œë”ë§ (í•„í„°ë§ ì ìš©)
                    if ($attributeFilterInput && $attributeFilterInput.value.trim()) {
                        loadAttributes();
                    }
                }, 300);
            });
        }
        
        // ì´ˆê¸°í™”: localStorageì—ì„œ ì„¤ì • ë¡œë“œ
        loadSearchSettingsFromStorage();
        
        // ì´ˆê¸°í™” í›„ ì†ì„± í•„í„°ì™€ ê²€ìƒ‰ ê²°ê³¼ í•„í„°ë§ ë™ê¸°í™”
        if ($attributeFilterInput && $searchFilterInput) {
            // ì†ì„± í•„í„° ê°’ì´ ìˆìœ¼ë©´ ê²€ìƒ‰ ê²°ê³¼ í•„í„°ë§ì— ë™ê¸°í™”
            if ($attributeFilterInput.value.trim()) {
                $searchFilterInput.value = $attributeFilterInput.value.trim();
            }
            // ê²€ìƒ‰ ê²°ê³¼ í•„í„°ë§ ê°’ì´ ìˆìœ¼ë©´ ì†ì„± í•„í„°ì— ë™ê¸°í™”
            else if ($searchFilterInput.value.trim()) {
                $attributeFilterInput.value = $searchFilterInput.value.trim();
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // HTML ì—”í‹°í‹° ë””ì½”ë” (ë°ì´í„° ìˆ˜ì§‘ìš©)
        function decodeHtmlEntities(text) {
            if (text === null || text === undefined) return '';
            const div = document.createElement('div');
            // hidden input value ë“±ì— ë“¤ì–´ìˆëŠ” ì¸ì½”ë”©ì„ ì •í™•íˆ ë³µì›
            div.innerHTML = String(text)
                .replace(/&quot;/g, '"')
                .replace(/&#x27;/g, "'");
            return div.textContent || div.innerText || '';
        }

        // ì €ì¥ëœ ì†ì„± ëª©ë¡ì˜ ì „ì²´ ë°ì´í„° â†’ GPT ìš”ì•½ â†’ ë¶„ì„ í…ìŠ¤íŠ¸ ì…ë ¥ ì±„ìš°ê¸°
        async function collectAllAttributesDataToInput() {
            const originalBtnText = $collectAllDataBtn ? $collectAllDataBtn.textContent : '';
            try {
                if ($collectAllDataBtn) {
                    $collectAllDataBtn.disabled = true;
                    $collectAllDataBtn.textContent = 'â³ ìš”ì•½ ì¤‘...';
                }
                if ($gptStatus) {
                    $gptStatus.textContent = 'ëª©ë¡ ë°ì´í„°ë¥¼ ìˆ˜ì§‘í•˜ê³  ìš”ì•½ ì¤‘...';
                    $gptStatus.style.color = '#007bff';
                }
                // ì‚¬ì „ ê²€ì¦: ì†Œì„¤ ì œëª©/ì±•í„° í•„ìš”
                const novelTitleCheck = $novelTitle ? ($novelTitle.value || '').trim() : '';
                const currentChapterCheck = (currentChapterIdx !== null && chapters[currentChapterIdx]) ? chapters[currentChapterIdx] : null;
                if (!novelTitleCheck || !currentChapterCheck) {
                    if ($gptStatus) {
                        $gptStatus.textContent = 'âœ— ì†Œì„¤ ì œëª©ê³¼ ì±•í„°ë¥¼ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”.';
                        $gptStatus.style.color = '#dc3545';
                    }
                    return;
                }
                if (!$attributesList) return;
                const attributeItems = $attributesList.querySelectorAll('.attribute-item');
                if (attributeItems.length === 0) {
                    alert('ìˆ˜ì§‘í•  í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤. ëª©ë¡ì„ ë¨¼ì € ë¶ˆëŸ¬ì˜¤ì„¸ìš”.');
                    return;
                }

                let outputParts = [];
                let attributeCount = 0;
                let dataCount = 0;

                attributeItems.forEach(attrItem => {
                    const dataItems = attrItem.querySelectorAll('.data-item');
                    if (!dataItems || dataItems.length === 0) return;

                    const attrText = (attrItem.getAttribute('data-attribute-text') || (attrItem.querySelector('.attribute-name')?.textContent || '')).trim();
                    if (attrText) {
                        attributeCount++;
                        outputParts.push(`ì†ì„±: ${attrText}`);
                    }

                    dataItems.forEach(di => {
                        // 1ìˆœìœ„: hidden input ê°’ (ì „ì²´ í…ìŠ¤íŠ¸ ì €ì¥ë¨)
                        let fullText = '';
                        const hidden = di.querySelector('input[type="hidden"]');
                        if (hidden && hidden.value) {
                            fullText = decodeHtmlEntities(hidden.value);
                        } else {
                            // 2ìˆœìœ„: í¸ì§‘ ë²„íŠ¼ì˜ data-text ì†ì„±
                            const editBtn = di.querySelector('.edit-data-btn');
                            if (editBtn) {
                                fullText = decodeHtmlEntities(editBtn.getAttribute('data-text') || '');
                            }
                        }
                        fullText = (fullText || '').trim();
                        if (fullText) {
                            dataCount++;
                            outputParts.push(`- ${fullText}`);
                        }
                    });

                    // ì†ì„± ê°„ ê³µë°± ë¼ì¸
                    if (outputParts.length > 0 && outputParts[outputParts.length - 1] !== '') {
                        outputParts.push('');
                    }
                });

                const collected = outputParts.join('\n').trim();
                if (!collected) {
                    alert('ìˆ˜ì§‘í•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
                    return;
                }

                // ì†Œì„¤/ì±•í„° ì»¨í…ìŠ¤íŠ¸ í¬í•¨
                const novelTitle = $novelTitle ? ($novelTitle.value || '').trim() : '';
                const currentChapter = (currentChapterIdx !== null && chapters[currentChapterIdx]) ? chapters[currentChapterIdx] : null;
                const chapterDisplay = currentChapter ? `${currentChapter.number || ''}${currentChapter.title ? `: ${currentChapter.title}` : ''}` : '';

                const systemMessage = `ë‹¹ì‹ ì€ ì†Œì„¤ êµ¬ì„± ë°ì´í„°ë¥¼ ì •ë°€í•˜ê²Œ í†µí•©Â·ìš”ì•½í•˜ëŠ” ì „ë¬¸ê°€ì…ë‹ˆë‹¤.

- ì¤‘ë³µê³¼ êµ°ë”ë”ê¸°ë¥¼ ì œê±°í•˜ê³  í•µì‹¬ë§Œ ë‚¨ê¹ë‹ˆë‹¤.
- ê°™ì€ ì˜ë¯¸ì˜ ë¬¸ì¥ì€ ë³‘í•©í•˜ê³ , ê³ ìœ ëª…ì‚¬/ê´€ê³„/ì‚¬ê±´ íë¦„ì€ ë³´ì¡´í•©ë‹ˆë‹¤.
- í•œêµ­ì–´ë¥¼ ìœ ì§€í•˜ê³ , ë§ˆí¬ë‹¤ìš´ í—¤ë”Â·ì½”ë“œë¸”ë¡Â·ë²ˆí˜¸ ë§¤ê¸°ê¸° ì—†ì´ ë¶ˆë¦¿(- )ë§Œ ì‚¬ìš©í•©ë‹ˆë‹¤.
- ê° ì¤„ì€ ê°„ê²°í•˜ê³  ëª…ë£Œí•˜ê²Œ ì‘ì„±í•©ë‹ˆë‹¤.

ë°˜ë“œì‹œ ì•„ë˜ ì„¹ì…˜ ë ˆì´ë¸”ê³¼ ìˆœì„œë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•´ ì¶œë ¥í•˜ì„¸ìš”:
ë“±ì¥ì¸ë¬¼:
- ì£¼ì¸ê³µ:
  - [ì´ë¦„] - ì—­í• Â·ì†Œì† | ëª©í‘œÂ·ê°ˆë“± | ì„±ê²©Â·ëŠ¥ë ¥ | ì£¼ìš” ê´€ê³„ | ë³€í™”(ìˆë‹¤ë©´)
- ì¡°ì—°:
  - [ì´ë¦„] - ì—­í• Â·ì†Œì† | ëª©í‘œÂ·ê°ˆë“± | ì„±ê²©Â·ëŠ¥ë ¥ | ì£¼ìš” ê´€ê³„ | ë³€í™”(ìˆë‹¤ë©´)
- ì—‘ìŠ¤íŠ¸ë¼:
  - [ì´ë¦„/ì§‘ë‹¨] - ê°„ë‹¨ ì„¤ëª…(ìˆë‹¤ë©´)
ì¥ì†Œ:
- [ì´ë¦„] - ìœ í˜• | ì‹œê¸°Â·ë§¥ë½ | ì‹œê°Â·ë¶„ìœ„ê¸° | ê¸°ëŠ¥(ì‚¬ê±´ì—ì„œì˜ ì—­í• ) | ê·œì¹™Â·ì œì•½ | ê´€ë ¨ ì¸ë¬¼Â·ì‚¬ê±´
ë°°ê²½:
- [í•µì‹¬ ì„¸ê³„ê´€/ì„¤ì • ë¶ˆë¦¿]
ì¤„ê±°ë¦¬:
- [ì¤‘ìš” ì‚¬ê±´ íë¦„ ë¶ˆë¦¿ 5~10ê°œ]
ë§ˆë¬´ë¦¬:
- [í˜„ì¬ê¹Œì§€ ìš”ì•½ 1~3ì¤„]
- [ë‹¤ìŒ ì „ê°œÂ·ê³¼ì œ 1~3ì¤„(ìˆë‹¤ë©´)]`;

                const userPrompt = `ì•„ë˜ëŠ” ì†ì„±ë³„ë¡œ ëª¨ì•„ ë‘” ì›ë³¸ ë°ì´í„°ì…ë‹ˆë‹¤. ì´ë¥¼ ë°”íƒ•ìœ¼ë¡œ "ìš”ì•½ ì •ë¦¬ë³¸"ì„ ì‘ì„±í•´ì£¼ì„¸ìš”.

ìš”ì²­ ê·œì¹™(ë°˜ë“œì‹œ ì¤€ìˆ˜):
1) ì„¹ì…˜ ìˆœì„œì™€ ë ˆì´ë¸”ì„ ì •í™•íˆ ì§€í‚¤ê¸°: ë“±ì¥ì¸ë¬¼ â†’ ì¥ì†Œ â†’ ë°°ê²½ â†’ ì¤„ê±°ë¦¬ â†’ ë§ˆë¬´ë¦¬.
2) ë“±ì¥ì¸ë¬¼ì€ ì£¼ì¸ê³µ/ì¡°ì—°/ì—‘ìŠ¤íŠ¸ë¼ë¡œ ë¶„ë¥˜í•˜ì—¬ ê° í•­ëª© í˜•ì‹ì„ ìœ ì§€(ì´ë¦„ - ì—­í• Â·ì†Œì† | ëª©í‘œÂ·ê°ˆë“± | ì„±ê²©Â·ëŠ¥ë ¥ | ì£¼ìš” ê´€ê³„ | ë³€í™”).
3) ì¥ì†ŒëŠ” ìœ í˜•/ë¶„ìœ„ê¸°/ì—­í• /ê·œì¹™ê¹Œì§€ í¬í•¨, ë°°ê²½ì€ ì„¸ê³„ê´€ í•µì‹¬ë§Œ.
4) ì¤„ê±°ë¦¬ëŠ” ì¤‘ìš” ì‚¬ê±´ íë¦„ 5~10ê°œ ë¶ˆë¦¿, ì‹œê°„ ìˆœìœ¼ë¡œ ê°„ê²°í•˜ê²Œ.
5) ë§ˆë¬´ë¦¬ëŠ” í˜„ì¬ ìƒí™© ìš”ì•½ 1~3ì¤„ + ë‹¤ìŒ ì „ê°œ/ê³¼ì œ 1~3ì¤„.
6) ë§ˆí¬ë‹¤ìš´ í—¤ë”/ì½”ë“œë¸”ë¡/ë²ˆí˜¸ ê¸ˆì§€, ë¶ˆë¦¿(- )ë§Œ ì‚¬ìš©.

${novelTitle ? `ì†Œì„¤: ${novelTitle}` : ''}${chapterDisplay ? ` | ì±•í„°: ${chapterDisplay}` : ''}

[ì›ë³¸ ë°ì´í„°]
${collected}`;

                // ë¡œê·¸ ê¸°ë¡ (ë°ì´í„° ì œì™¸ í¬ë§·)
                if (typeof updatePromptLog2 === 'function') {
                    const loggedPrompt = userPrompt.replace(/\[ì›ë³¸ ë°ì´í„°\][\s\S]*/m, '[ì›ë³¸ ë°ì´í„°]\n(ë°ì´í„° ì œì™¸)');
                    updatePromptLog2(systemMessage, loggedPrompt);
                }

                // GPT í˜¸ì¶œ (ìš”ì•½)
                const url = getServerUrl('/api/gpt/chat');
                const res = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: userPrompt,
                        systemMessage: systemMessage,
                        model: 'gpt-4o-mini',
                        temperature: 0.2,
                        maxTokens: 1400
                    })
                });

                if (!res.ok) {
                    const raw = await res.text().catch(() => '');
                    throw new Error(raw || `HTTP ${res.status}`);
                }
                const data = await res.json();
                if (!data.ok || !data.response) {
                    throw new Error(data.error || 'ìš”ì•½ ìƒì„± ì‹¤íŒ¨');
                }

                const summaryText = (data.response || '').trim();
                if ($gptInput) {
                    $gptInput.value = summaryText;
                    $gptInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
                if ($gptStatus) {
                    $gptStatus.textContent = `âœ“ GPT ìš”ì•½ ì™„ë£Œ: ì†ì„± ${attributeCount}ê°œ, ë°ì´í„° ${dataCount}ê°œ`;
                    $gptStatus.style.color = '#28a745';
                }
                addLog('info', `ëª©ë¡ ìš”ì•½ ì™„ë£Œ: ì†ì„± ${attributeCount}ê°œ, ë°ì´í„° ${dataCount}ê°œ`);

                // ì±•í„°ì— ë¶„ì„ ë‚´ìš© ì €ì¥ ë° ê²Œì‹œ ì²˜ë¦¬
                saveChapterAnalysis(summaryText, true);
            } catch (e) {
                console.error('ë°ì´í„° ìˆ˜ì§‘/ìš”ì•½ ì˜¤ë¥˜:', e);
                if ($gptStatus) {
                    $gptStatus.textContent = `âœ— ìš”ì•½ ì‹¤íŒ¨: ${e.message}`;
                    $gptStatus.style.color = '#dc3545';
                }
            } finally {
                if ($collectAllDataBtn) {
                    $collectAllDataBtn.disabled = false;
                    $collectAllDataBtn.textContent = originalBtnText || 'ğŸ“¥ ë¶„ì„ ì…ë ¥';
                }
            }
        }

        // ë°ì´í„° í…ìŠ¤íŠ¸ ë³µì‚¬ í•¨ìˆ˜ (hidden inputì—ì„œ í…ìŠ¤íŠ¸ ê°€ì ¸ì˜¤ê¸°)
        function copyDataTextFromHidden(id) {
            try {
                const hiddenInput = document.getElementById(id);
                if (!hiddenInput) {
                    alert('ë³µì‚¬í•  ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                    return;
                }
                
                // ë²„íŠ¼ ì°¾ê¸° (hidden inputì˜ ë¶€ëª¨ì—ì„œ ì°¾ê¸°)
                const dataItem = hiddenInput.closest('.data-item');
                const btn = dataItem ? dataItem.querySelector('button') : null;
                
                // &quot; ë“±ì„ ì›ë˜ ë¬¸ìë¡œ ë³µì›
                const textToCopy = hiddenInput.value
                    .replace(/&quot;/g, '"')
                    .replace(/&#x27;/g, "'")
                    .replace(/&amp;/g, '&')
                    .replace(/&lt;/g, '<')
                    .replace(/&gt;/g, '>');
                
                navigator.clipboard.writeText(textToCopy).then(() => {
                    console.log('ë°ì´í„° ë³µì‚¬ ì™„ë£Œ');
                    
                    // ë³µì‚¬ ë²„íŠ¼ í”¼ë“œë°±
                    if (btn) {
                        const originalText = btn.innerHTML;
                        btn.innerHTML = 'âœ“ ë³µì‚¬ë¨';
                        btn.classList.remove('btn-outline-secondary');
                        btn.classList.add('btn-success');
                        
                        setTimeout(() => {
                            btn.innerHTML = originalText;
                            btn.classList.remove('btn-success');
                            btn.classList.add('btn-outline-secondary');
                        }, 2000);
                    }
                }).catch(err => {
                    console.error('ë³µì‚¬ ì‹¤íŒ¨:', err);
                    // í´ë°±: í…ìŠ¤íŠ¸ ì˜ì—­ ì‚¬ìš©
                    try {
                        const textarea = document.createElement('textarea');
                        textarea.value = textToCopy;
                        document.body.appendChild(textarea);
                        textarea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textarea);
                        
                        if (btn) {
                            const originalText = btn.innerHTML;
                            btn.innerHTML = 'âœ“ ë³µì‚¬ë¨';
                            btn.classList.remove('btn-outline-secondary');
                            btn.classList.add('btn-success');
                            
                            setTimeout(() => {
                                btn.innerHTML = originalText;
                                btn.classList.remove('btn-success');
                                btn.classList.add('btn-outline-secondary');
                            }, 2000);
                        }
                    } catch (fallbackErr) {
                        console.error('ë³µì‚¬ í´ë°± ì‹¤íŒ¨:', fallbackErr);
                        alert('ë³µì‚¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                    }
                });
            } catch (e) {
                console.error('ë³µì‚¬ ì˜¤ë¥˜:', e);
                alert('ë³µì‚¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            }
        }
        
        // ì „ì—­ í•¨ìˆ˜ë¡œ ë“±ë¡
        window.copyDataTextFromHidden = copyDataTextFromHidden;
        
        // ë°ì´í„° ì‚­ì œ í•¨ìˆ˜
        async function deleteAttributeData(attrBitMax, attrBitMin, dataBitMax, dataBitMin, dataText) {
            // dataTextëŠ” HTML ì´ìŠ¤ì¼€ì´í”„ëœ ë¬¸ìì—´ì´ë¯€ë¡œ ë””ì½”ë”© í•„ìš”
            let previewText = '';
            try {
                // HTML ì—”í‹°í‹° ë””ì½”ë”©
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = dataText.replace(/&quot;/g, '"');
                previewText = tempDiv.textContent || tempDiv.innerText || dataText;
                // ë¯¸ë¦¬ë³´ê¸°ëŠ” 50ìë¡œ ì œí•œ
                previewText = previewText.substring(0, 50) + (previewText.length > 50 ? '...' : '');
            } catch (e) {
                previewText = (dataText || '').substring(0, 50);
            }
            
            // í™•ì¸ì€ ëª¨ë‹¬ë¡œ ëŒ€ì²´í•  ìˆ˜ë„ ìˆì§€ë§Œ, ê°„ë‹¨í•˜ê²Œ ë¡œê·¸ë¡œ í‘œì‹œ
            console.log('ë°ì´í„° ì‚­ì œ ì‹œì‘:', { attrBitMax, attrBitMin, dataBitMax, dataBitMin, previewText });
            
            try {
                // POST ë©”ì„œë“œë¡œ ì‚­ì œ ìš”ì²­ (ì„œë²„ê°€ DELETEë¥¼ ì§€ì›í•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŒ)
                const url = getServerUrl('/api/attributes/data/delete');
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        attributeBitMax: parseFloat(attrBitMax),
                        attributeBitMin: parseFloat(attrBitMin),
                        dataBitMax: parseFloat(dataBitMax),
                        dataBitMin: parseFloat(dataBitMin)
                    })
                });
                
                if (!response.ok) {
                    let errorText = '';
                    try {
                        errorText = await response.text();
                    } catch (e) {
                        errorText = `HTTP ${response.status}`;
                    }
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }
                
                let result = null;
                try {
                    result = await response.json();
                } catch (e) {
                    console.warn('ì‘ë‹µ JSON íŒŒì‹± ì‹¤íŒ¨, ë¹ˆ ì‘ë‹µìœ¼ë¡œ ì²˜ë¦¬');
                    result = { ok: true };
                }
                
                if (result && result.ok) {
                    console.log('ë°ì´í„° ì‚­ì œ ì™„ë£Œ:', result);
                    // ë¡œê·¸ì— ì„±ê³µ ë©”ì‹œì§€ ì¶”ê°€
                    addLog('info', `ë°ì´í„° ì‚­ì œ ì™„ë£Œ: ${previewText}`);
                    // ì†ì„± ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                    loadAttributes();
                } else {
                    const errorMsg = result?.message || result?.error || 'ì‚­ì œ ì‹¤íŒ¨';
                    console.error('ë°ì´í„° ì‚­ì œ ì‹¤íŒ¨:', errorMsg, result);
                    addLog('error', `ë°ì´í„° ì‚­ì œ ì‹¤íŒ¨: ${errorMsg}`);
                    throw new Error(errorMsg);
                }
            } catch (error) {
                const errorMsg = error.message || String(error) || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜';
                console.error('ë°ì´í„° ì‚­ì œ ì˜¤ë¥˜:', error, errorMsg);
                addLog('error', `ë°ì´í„° ì‚­ì œ ì˜¤ë¥˜: ${errorMsg}`);
            }
        }
        
        // ì „ì—­ í•¨ìˆ˜ë¡œ ë“±ë¡
        window.deleteAttributeData = deleteAttributeData;

        // ë°ì´í„° ìˆ˜ì • ëª¨ë‹¬ ì—´ê¸°
        function openEditDataModal(attrBitMax, attrBitMin, dataBitMax, dataBitMin, dataText) {
            currentEditData = {
                attrBitMax: parseFloat(attrBitMax),
                attrBitMin: parseFloat(attrBitMin),
                dataBitMax: parseFloat(dataBitMax),
                dataBitMin: parseFloat(dataBitMin),
                originalText: dataText
            };
            
            // ì†ì„± ì •ë³´ ì°¾ê¸°
            const attrItem = document.querySelector(`.attribute-item[data-bit-max="${attrBitMax}"][data-bit-min="${attrBitMin}"]`);
            const attributeText = attrItem ? attrItem.getAttribute('data-attribute-text') : 'ì†ì„± ì •ë³´ ì—†ìŒ';
            
            $editModalAttributeName.textContent = attributeText;
            $editModalAttributeMax.textContent = attrBitMax.toFixed(15);
            $editModalAttributeMin.textContent = attrBitMin.toFixed(15);
            $editModalDataBitMax.textContent = dataBitMax.toFixed(15);
            $editModalDataBitMin.textContent = dataBitMin.toFixed(15);
            $editDataInput.value = dataText;
            $editDataMax.textContent = '-';
            $editDataMin.textContent = '-';
            $updateDataStatus.textContent = '';
            
            editDataModal.show();
        }
        
        // ì „ì—­ í•¨ìˆ˜ë¡œ ë“±ë¡
        window.openEditDataModal = openEditDataModal;
        
        // ìˆ˜ì • ë°ì´í„° ì…ë ¥ ì‹œ BIT ê³„ì‚°
        $editDataInput.addEventListener('input', (e) => {
            const text = e.target.value.trim();
            if (text) {
                const { max, min } = calculateBitValues(text);
                $editDataMax.textContent = max !== null && max !== undefined ? max.toFixed(15) : '-';
                $editDataMin.textContent = min !== null && min !== undefined ? min.toFixed(15) : '-';
            } else {
                $editDataMax.textContent = '-';
                $editDataMin.textContent = '-';
            }
        });
        
        // ë°ì´í„° ìˆ˜ì • ì €ì¥
        $updateDataBtn.addEventListener('click', async () => {
            console.log('ë°ì´í„° ìˆ˜ì • ë²„íŠ¼ í´ë¦­');
            
            if (!currentEditData) {
                console.warn('ë°ì´í„° ìˆ˜ì •: ìˆ˜ì •í•  ë°ì´í„° ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.');
                $updateDataStatus.textContent = 'âœ— ìˆ˜ì •í•  ë°ì´í„° ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.';
                $updateDataStatus.style.color = '#dc3545';
                return;
            }
            
            const dataText = $editDataInput.value.trim();
            if (!dataText) {
                console.warn('ë°ì´í„° ìˆ˜ì •: ë°ì´í„°ê°€ ì…ë ¥ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                $updateDataStatus.textContent = 'âœ— ë°ì´í„°ë¥¼ ì…ë ¥í•˜ì„¸ìš”.';
                $updateDataStatus.style.color = '#dc3545';
                return;
            }
            
            // ì†Œì„¤ ì œëª©ê³¼ ì±•í„° ì •ë³´ í™•ì¸
            const novelTitle = $novelTitle.value.trim();
            const currentChapter = currentChapterIdx !== null && chapters[currentChapterIdx] ? chapters[currentChapterIdx] : null;
            
            if (!novelTitle) {
                console.warn('ë°ì´í„° ìˆ˜ì •: ì†Œì„¤ ì œëª©ì´ ì…ë ¥ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                $updateDataStatus.textContent = 'âœ— ì†Œì„¤ ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš”.';
                $updateDataStatus.style.color = '#dc3545';
                return;
            }
            
            if (!currentChapter) {
                console.warn('ë°ì´í„° ìˆ˜ì •: ì±•í„°ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                $updateDataStatus.textContent = 'âœ— ì±•í„°ë¥¼ ì„ íƒí•˜ì„¸ìš”.';
                $updateDataStatus.style.color = '#dc3545';
                return;
            }
            
            // ìƒˆë¡œìš´ ë°ì´í„° BIT ê³„ì‚°
            const { max: newDataBitMax, min: newDataBitMin } = calculateBitValues(dataText);
            if (newDataBitMax === null || newDataBitMin === null) {
                console.error('ë°ì´í„° ìˆ˜ì •: BIT ê°’ ê³„ì‚° ì‹¤íŒ¨');
                $updateDataStatus.textContent = 'âœ— BIT ê°’ ê³„ì‚° ì‹¤íŒ¨.';
                $updateDataStatus.style.color = '#dc3545';
                return;
            }
            
            try {
                $updateDataBtn.disabled = true;
                $updateDataStatus.textContent = 'ìˆ˜ì • ì¤‘...';
                $updateDataStatus.style.color = '#007bff';
                
                // 1. ê¸°ì¡´ ë°ì´í„° ì‚­ì œ
                console.log('ê¸°ì¡´ ë°ì´í„° ì‚­ì œ ì‹œì‘');
                const deleteUrl = getServerUrl('/api/attributes/data/delete');
                const deleteRes = await fetch(deleteUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        attributeBitMax: currentEditData.attrBitMax,
                        attributeBitMin: currentEditData.attrBitMin,
                        dataBitMax: currentEditData.dataBitMax,
                        dataBitMin: currentEditData.dataBitMin
                    })
                });
                
                if (!deleteRes.ok) {
                    const errorText = await deleteRes.text();
                    throw new Error(`ì‚­ì œ ì‹¤íŒ¨: HTTP ${deleteRes.status}: ${errorText}`);
                }
                
                const deleteData = await deleteRes.json();
                console.log('ê¸°ì¡´ ë°ì´í„° ì‚­ì œ ì™„ë£Œ', deleteData);
                
                // 2. ìƒˆ ë°ì´í„° ì €ì¥
                console.log('ìƒˆ ë°ì´í„° ì €ì¥ ì‹œì‘');
                const novelTitleBits = calculateBitValues(novelTitle);
                const chapterText = `${currentChapter.number || ''} ${currentChapter.title || ''}`.trim();
                const chapterBits = calculateBitValues(chapterText);
                
                // ì†ì„± ì •ë³´ ì°¾ê¸°
                const attrItem = document.querySelector(`.attribute-item[data-bit-max="${currentEditData.attrBitMax}"][data-bit-min="${currentEditData.attrBitMin}"]`);
                const attributeText = attrItem ? attrItem.getAttribute('data-attribute-text') : '';
                
                const saveUrl = getServerUrl('/api/attributes/data');
                const saveRes = await fetch(saveUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        attributeText: attributeText,
                        attributeBitMax: currentEditData.attrBitMax,
                        attributeBitMin: currentEditData.attrBitMin,
                        text: dataText,
                        dataBitMax: newDataBitMax,
                        dataBitMin: newDataBitMin,
                        novelTitle: novelTitle,
                        novelTitleBitMax: novelTitleBits.max,
                        novelTitleBitMin: novelTitleBits.min,
                        chapter: currentChapter,
                        chapterBitMax: chapterBits.max,
                        chapterBitMin: chapterBits.min
                    })
                });
                
                if (!saveRes.ok) {
                    const errorText = await saveRes.text();
                    throw new Error(`ì €ì¥ ì‹¤íŒ¨: HTTP ${saveRes.status}: ${errorText}`);
                }
                
                const saveData = await saveRes.json();
                console.log('ìƒˆ ë°ì´í„° ì €ì¥ ì™„ë£Œ', saveData);
                
                if (saveData.ok) {
                    $updateDataStatus.textContent = 'âœ“ ë°ì´í„° ìˆ˜ì • ì™„ë£Œ';
                    $updateDataStatus.style.color = '#28a745';
                    
                    setTimeout(() => {
                        editDataModal.hide();
                        loadAttributes();
                    }, 1000);
                } else {
                    throw new Error(saveData.error || 'ì €ì¥ ì‹¤íŒ¨');
                }
            } catch (e) {
                console.error('ë°ì´í„° ìˆ˜ì • ì˜¤ë¥˜:', e);
                $updateDataStatus.textContent = `âœ— ìˆ˜ì • ì‹¤íŒ¨: ${e.message}`;
                $updateDataStatus.style.color = '#dc3545';
            } finally {
                $updateDataBtn.disabled = false;
            }
        });

        // ===== ì´ˆê¸°í™” ë¡œì§ =====
        async function resetAttributesOnServer() {
            try {
                // 1) ì„œë²„ì— ë¦¬ì…‹ ì—”ë“œí¬ì¸íŠ¸ê°€ ìˆìœ¼ë©´ ìš°ì„  ì‹œë„
                try {
                    const resetUrl = getServerUrl('/api/attributes/reset');
                    const res = await fetch(resetUrl, { method: 'POST' });
                    if (res.ok) {
                        const data = await res.json().catch(() => ({ ok: true }));
                        if (!data || data.ok) {
                            addLog('info', 'ì„œë²„ ì†ì„± ì „ì²´ ë¦¬ì…‹ ì™„ë£Œ');
                            return;
                        }
                    }
                } catch (e) {
                    console.warn('ë¦¬ì…‹ ì—”ë“œí¬ì¸íŠ¸ ë¯¸ì§€ì› ë˜ëŠ” ì‹¤íŒ¨, ìˆ˜ë™ ì‚­ì œë¡œ ì§„í–‰');
                }

                // 2) ëª¨ë“  ì†ì„±ì˜ ë°ì´í„° í•­ëª© ì¼ê´„ ì‚­ì œ (ì†ì„± ìì²´ ì‚­ì œ APIê°€ ì—†ì„ ìˆ˜ ìˆìŒ)
                const allUrl = getServerUrl('/api/attributes/all');
                const allRes = await fetch(allUrl);
                if (!allRes.ok) return;
                const allData = await allRes.json();
                if (!allData.ok || !allData.attributes) return;

                for (const attr of allData.attributes) {
                    try {
                        const dataUrl = getServerUrl(`/api/attributes/data?bitMax=${attr.bitMax}&bitMin=${attr.bitMin}&limit=1000`);
                        const dataRes = await fetch(dataUrl);
                        if (!dataRes.ok) continue;
                        const dataData = await dataRes.json();
                        if (!dataData.ok || !dataData.items) continue;
                        for (const item of dataData.items) {
                            try {
                                const delUrl = getServerUrl('/api/attributes/data/delete');
                                await fetch(delUrl, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        attributeBitMax: parseFloat(attr.bitMax),
                                        attributeBitMin: parseFloat(attr.bitMin),
                                        dataBitMax: parseFloat(item.data?.bitMax ?? item.bitMax),
                                        dataBitMin: parseFloat(item.data?.bitMin ?? item.bitMin)
                                    })
                                });
                            } catch (e) {
                                console.warn('ë°ì´í„° ì‚­ì œ ì‹¤íŒ¨:', e);
                            }
                        }
                    } catch (e) {
                        console.warn('ì†ì„± ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨:', e);
                    }
                }
                addLog('info', 'ì„œë²„ ì €ì¥ ë°ì´í„° ì´ˆê¸°í™”(ë°ì´í„° í•­ëª©) ì™„ë£Œ');
            } catch (e) {
                console.warn('ì„œë²„ ì´ˆê¸°í™” ì¤‘ ì˜¤ë¥˜:', e);
            }
        }

        async function resetAll() {
            try {
                const confirmed = confirm('ì •ë§ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n- ì±•í„° êµ¬ì„±, ì†Œì„¤ ì œëª©, ê²€ìƒ‰ ì„¤ì •\n- ì €ì¥ëœ ì†ì„± ë°ì´í„°(ì„œë²„)\nëª¨ë‘ ì´ˆê¸°í™”ë©ë‹ˆë‹¤.');
                if (!confirmed) return;

                // 1) ë¡œì»¬ ìƒíƒœ ì´ˆê¸°í™”
                chapters = [];
                currentChapterIdx = null;
                if ($novelTitle) $novelTitle.value = '';
                if ($novelTitleBitMax) $novelTitleBitMax.textContent = '-';
                if ($novelTitleBitMin) $novelTitleBitMin.textContent = '-';
                if ($gptInput) $gptInput.value = '';
                if ($gptResponse) $gptResponse.textContent = '';
                if ($extractedAttributes) $extractedAttributes.innerHTML = '';

                // 2) localStorage ì´ˆê¸°í™”
                localStorage.removeItem(STORAGE_KEY_NOVEL_TITLE);
                localStorage.removeItem(STORAGE_KEY_CHAPTERS);
                localStorage.removeItem(STORAGE_KEY_CURRENT_CHAPTER);
                localStorage.removeItem(STORAGE_KEY_ATTRIBUTE_FILTER);
                localStorage.removeItem(STORAGE_KEY_ADDITIONAL_SEARCH);
                localStorage.removeItem(STORAGE_KEY_SEARCH_FILTER);

                renderChapters();
                saveChapters();

                if ($attributesList) {
                    $attributesList.innerHTML = '<div class="text-center text-muted">ì´ˆê¸°í™” ì¤‘...</div>';
                }

                if ($gptStatus) {
                    $gptStatus.textContent = 'ì„œë²„ ë°ì´í„° ì´ˆê¸°í™” ì¤‘...';
                    $gptStatus.style.color = '#007bff';
                }
                await resetAttributesOnServer();

                // 3) ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                await loadAttributes();
                if ($gptStatus) {
                    $gptStatus.textContent = 'âœ“ ì´ˆê¸°í™” ì™„ë£Œ';
                    $gptStatus.style.color = '#28a745';
                }
                addLog('info', 'ì „ì²´ ì´ˆê¸°í™” ì™„ë£Œ');
            } catch (e) {
                console.error('ì´ˆê¸°í™” ì˜¤ë¥˜:', e);
                if ($gptStatus) {
                    $gptStatus.textContent = `âœ— ì´ˆê¸°í™” ì‹¤íŒ¨: ${e.message}`;
                    $gptStatus.style.color = '#dc3545';
                }
            }
        }

        if ($resetAllBtn) {
            $resetAllBtn.addEventListener('click', () => {
                console.log('ì „ì²´ ì´ˆê¸°í™” ë²„íŠ¼ í´ë¦­');
                resetAll();
            });
        }

        // ë°ì´í„° ì¶”ê°€ ëª¨ë‹¬ ì—´ê¸°
        window.openAddDataModal = function(attributeText, attributeBitMax, attributeBitMin) {
            currentAttribute = {
                text: attributeText,
                bitMax: attributeBitMax,
                bitMin: attributeBitMin
            };
            
            $modalAttributeName.textContent = attributeText;
            $modalAttributeMax.textContent = attributeBitMax.toFixed(15);
            $modalAttributeMin.textContent = attributeBitMin.toFixed(15);
            $newDataInput.value = '';
            $newDataMax.textContent = '-';
            $newDataMin.textContent = '-';
            $saveDataStatus.textContent = '';
            
            addDataModal.show();
        };

        // ë°ì´í„° ì €ì¥
        $saveDataBtn.addEventListener('click', async () => {
            console.log('ë°ì´í„° ì €ì¥ ë²„íŠ¼ í´ë¦­');
            
            if (!currentAttribute) {
                console.warn('ë°ì´í„° ì €ì¥: ì†ì„± ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.');
                $saveDataStatus.textContent = 'âœ— ì†ì„± ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.';
                $saveDataStatus.style.color = '#dc3545';
                return;
            }

            const dataText = $newDataInput.value.trim();
            if (!dataText) {
                console.warn('ë°ì´í„° ì €ì¥: ë°ì´í„°ê°€ ì…ë ¥ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                $saveDataStatus.textContent = 'âœ— ë°ì´í„°ë¥¼ ì…ë ¥í•˜ì„¸ìš”.';
                $saveDataStatus.style.color = '#dc3545';
                return;
            }

            console.log('ë°ì´í„° ì €ì¥ ì‹œì‘', { attribute: currentAttribute.text, dataLength: dataText.length });
            
            const { max, min } = calculateBitValues(dataText);
            console.log('ë°ì´í„° BIT ê³„ì‚°', { max, min });
            
            if (max === null || min === null) {
                console.error('ë°ì´í„° ì €ì¥: BIT ê°’ ê³„ì‚° ì‹¤íŒ¨');
                $saveDataStatus.textContent = 'âœ— BIT ê°’ ê³„ì‚° ì‹¤íŒ¨.';
                $saveDataStatus.style.color = '#dc3545';
                return;
            }

            // ì†Œì„¤ ì œëª©ê³¼ ì±•í„° ì •ë³´ í™•ì¸
            const novelTitle = $novelTitle.value.trim();
            const currentChapter = currentChapterIdx !== null && chapters[currentChapterIdx] ? chapters[currentChapterIdx] : null;
            
            if (!novelTitle) {
                console.warn('ë°ì´í„° ì €ì¥: ì†Œì„¤ ì œëª©ì´ ì…ë ¥ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                $saveDataStatus.textContent = 'âœ— ì†Œì„¤ ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš”.';
                $saveDataStatus.style.color = '#dc3545';
                return;
            }
            
            if (!currentChapter) {
                console.warn('ë°ì´í„° ì €ì¥: ì±•í„°ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                $saveDataStatus.textContent = 'âœ— ì±•í„°ë¥¼ ì„ íƒí•˜ì„¸ìš”.';
                $saveDataStatus.style.color = '#dc3545';
                return;
            }

            // ì†Œì„¤ ì œëª© BIT ê³„ì‚°
            const novelTitleBits = calculateBitValues(novelTitle);
            if (novelTitleBits.max === null || novelTitleBits.min === null) {
                console.error('ë°ì´í„° ì €ì¥: ì†Œì„¤ ì œëª© BIT ê°’ ê³„ì‚° ì‹¤íŒ¨');
                $saveDataStatus.textContent = 'âœ— ì†Œì„¤ ì œëª© BIT ê³„ì‚° ì‹¤íŒ¨.';
                $saveDataStatus.style.color = '#dc3545';
                return;
            }

            // ì±•í„° BIT ê³„ì‚°
            const chapterText = `${currentChapter.number || ''} ${currentChapter.title || ''}`.trim();
            const chapterBits = calculateBitValues(chapterText);
            if (chapterBits.max === null || chapterBits.min === null) {
                console.error('ë°ì´í„° ì €ì¥: ì±•í„° BIT ê°’ ê³„ì‚° ì‹¤íŒ¨');
                $saveDataStatus.textContent = 'âœ— ì±•í„° BIT ê³„ì‚° ì‹¤íŒ¨.';
                $saveDataStatus.style.color = '#dc3545';
                return;
            }

            try {
                $saveDataBtn.disabled = true;
                $saveDataStatus.textContent = 'ì €ì¥ ì¤‘...';
                $saveDataStatus.style.color = '#007bff';

                console.log('ë°ì´í„° ì €ì¥ API ìš”ì²­', { 
                    novelTitle, 
                    novelTitleBits,
                    chapter: currentChapter,
                    chapterBits
                });
                const url = getServerUrl('/api/attributes/data');
                const res = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        attributeText: currentAttribute.text,
                        attributeBitMax: currentAttribute.bitMax,
                        attributeBitMin: currentAttribute.bitMin,
                        text: dataText,
                        dataBitMax: max,
                        dataBitMin: min,
                        novelTitle: novelTitle,
                        novelTitleBitMax: novelTitleBits.max,
                        novelTitleBitMin: novelTitleBits.min,
                        chapter: currentChapter,
                        chapterBitMax: chapterBits.max,
                        chapterBitMin: chapterBits.min
                    })
                });

                console.log('ë°ì´í„° ì €ì¥ API ì‘ë‹µ', { status: res.status });

                if (!res.ok) {
                    const errorText = await res.text();
                    console.error('ë°ì´í„° ì €ì¥ API ì˜¤ë¥˜', { status: res.status, error: errorText });
                    throw new Error(`HTTP ${res.status}: ${errorText}`);
                }

                const data = await res.json();
                console.log('ë°ì´í„° ì €ì¥ ê²°ê³¼', { ok: data.ok, duplicate: data.duplicate });
                
                if (!data.ok) {
                    throw new Error(data.error || 'ì €ì¥ ì‹¤íŒ¨');
                }

                if (data.duplicate) {
                    console.warn('ë°ì´í„° ì¤‘ë³µ ì €ì¥ ì‹œë„');
                    $saveDataStatus.textContent = 'âš  ì´ë¯¸ ë™ì¼í•œ ë°ì´í„°ê°€ ì €ì¥ë˜ì–´ ìˆìŠµë‹ˆë‹¤.';
                    $saveDataStatus.style.color = '#ffc107';
                } else {
                    console.log('ë°ì´í„° ì €ì¥ ì™„ë£Œ');
                    $saveDataStatus.textContent = 'âœ“ ë°ì´í„° ì €ì¥ ì™„ë£Œ';
                    $saveDataStatus.style.color = '#28a745';
                    $newDataInput.value = '';
                    $newDataMax.textContent = '-';
                    $newDataMin.textContent = '-';
                    
                    setTimeout(() => {
                        addDataModal.hide();
                        loadAttributes();
                    }, 1000);
                }
            } catch (e) {
                console.error('ë°ì´í„° ì €ì¥ ì˜¤ë¥˜:', e);
                $saveDataStatus.textContent = `âœ— ì €ì¥ ì‹¤íŒ¨: ${e.message}`;
                $saveDataStatus.style.color = '#dc3545';
            } finally {
                $saveDataBtn.disabled = false;
            }
        });

        // ì†ì„±ìœ¼ë¡œ ê²€ìƒ‰
        window.searchByAttribute = function(attributeText, attributeBitMax, attributeBitMin) {
            window.location.href = `bit_search.html?attribute=${encodeURIComponent(attributeText)}&bitMax=${attributeBitMax}&bitMin=${attributeBitMin}`;
        };

        // ìƒˆë¡œê³ ì¹¨
        $refreshBtn.addEventListener('click', () => {
            console.log('ì†ì„± ëª©ë¡ ìƒˆë¡œê³ ì¹¨ ë²„íŠ¼ í´ë¦­');
            loadAttributes();
        });

        // ê²Œì‹œëœ ì±•í„° ë¶„ì„ í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥ë€ìœ¼ë¡œ ë³µì‚¬
        function analysisToInputFromChapter(idx) {
            if (idx === null || idx === undefined || idx < 0 || idx >= chapters.length) {
                console.warn('ì˜ëª»ëœ ì±•í„° ì¸ë±ìŠ¤:', idx);
                return;
            }
            const chapter = chapters[idx];
            const text = (chapter && chapter.analysisText) ? chapter.analysisText.trim() : '';
            if (!text) {
                alert('ì´ ì±•í„°ì— ì €ì¥ëœ ë¶„ì„ ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }
            if ($gptInput) {
                $gptInput.value = text;
                $gptInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
            if ($gptStatus) {
                $gptStatus.textContent = 'âœ“ ê²Œì‹œëœ ë¶„ì„ ë‚´ìš©ì„ ì…ë ¥ë€ì— ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.';
                $gptStatus.style.color = '#28a745';
            }
            addLog('info', `ë¶„ì„ ì…ë ¥ìœ¼ë¡œ ë¶ˆëŸ¬ì˜¤ê¸°: ${chapter.number || ''} ${chapter.title || ''}`);
        }

        // ì „ì²´ ë°ì´í„° ìˆ˜ì§‘ â†’ ë¶„ì„ ì…ë ¥
        if ($collectAllDataBtn) {
            $collectAllDataBtn.addEventListener('click', () => {
                console.log('ì „ì²´ ë°ì´í„° ìˆ˜ì§‘ ë²„íŠ¼ í´ë¦­');
                collectAllAttributesDataToInput();
            });
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ localStorageì—ì„œ ë°ì´í„° ë³µì›
        console.log('í˜ì´ì§€ ë¡œë“œ ì™„ë£Œ, ë°ì´í„° ë³µì› ì‹œì‘');
        loadNovelTitle();
        renderTitleDatalist();
        
        // ì†Œì„¤ ì œëª© BIT ê°’ ê³„ì‚° ë° í‘œì‹œ (ë³µì› í›„)
        // BIT ìŠ¤í¬ë¦½íŠ¸ê°€ ë¡œë“œë  ë•Œê¹Œì§€ ëŒ€ê¸°
        function initAfterBitScript() {
            if (typeof wordNbUnicodeFormat === 'undefined' || typeof BIT_MAX_NB === 'undefined' || typeof BIT_MIN_NB === 'undefined') {
                setTimeout(initAfterBitScript, 100);
                return;
            }
            
            const savedTitle = $novelTitle.value.trim();
            if (savedTitle) {
                updateNovelTitleBits(savedTitle);
            }
        }
        
        initAfterBitScript();
        loadChapters();
        
        // ì±•í„° ë¡œë“œ í›„ í•„í„° ì…ë ¥ë€ ë™ê¸°í™”
        setTimeout(() => {
            syncFilterInputs();
        }, 300);
        
        // ì†ì„± ëª©ë¡ ë¡œë“œ
        loadAttributes();
    </script>
</body>
</html>

